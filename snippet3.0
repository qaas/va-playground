Option Explicit

' =================================== GLOBAL VARIABLES ===================================
Dim gstrInputFileAPath As String
Dim gstrInputFileBPath As String
Dim gstrSupplementaryFileAPath As String
Dim gstrSupplementaryFileBPath As String
Dim gstrInputASource As String
Dim gstrInputBSource As String
Dim gstrInputADelimiter As String
Dim gstrInputBDelimiter As String
Dim gstrSupplementaryADelimiter As String
Dim gstrSupplementaryBDelimiter As String
Dim gstrPrimaryKeyA As String
Dim gstrPrimaryKeyB As String
Dim gstrSecondaryKeyA As String
Dim gstrSecondaryKeyB As String
Dim gstrSupplementaryKeyA As String
Dim gstrSupplementaryKeyB As String
Dim gstrSupplementaryASourceKey As String
Dim gstrSupplementaryBSourceKey As String

'******* Temp function *********'
Sub UpdateMappingTableFormat()
    ' Updates the format of mapping tables in the Mapping worksheet
    On Error GoTo ErrorHandler
    
    Dim wsMappingDef As Worksheet
    Dim rangeToSearch As Range
    Dim cell As Range
    Dim i As Long
    Dim tableStartRows() As Long
    Dim tableStartCols() As Long
    Dim tableCount As Long
    Dim columnName As String
    
    ' Set worksheet
    Set wsMappingDef = Worksheets("Mapping")
    
    ' Find all mapping tables in the Mapping sheet
    tableCount = 0
    ReDim tableStartRows(1 To 100) ' Assume max 100 mapping tables
    ReDim tableStartCols(1 To 100) ' Store start column for each table
    
    ' Search for "Input File: " text to find mapping table starts
    Set rangeToSearch = wsMappingDef.UsedRange
    
    For Each cell In rangeToSearch.Cells
        If InStr(1, cell.Value, "Input File:", vbTextCompare) > 0 Then
            tableCount = tableCount + 1
            tableStartRows(tableCount) = cell.Row
            tableStartCols(tableCount) = cell.Column
        End If
    Next cell
    
    ' If no mapping tables found, exit
    If tableCount = 0 Then
        MsgBox "No mapping tables found in the Mapping sheet.", vbInformation, "No Mapping Tables"
        Exit Sub
    End If
    
    ' Process each mapping table
    For i = 1 To tableCount
        Dim startRow As Long, startCol As Long
        startRow = tableStartRows(i)
        startCol = tableStartCols(i)
        
        ' Check if the table is already in the new format
        If wsMappingDef.Cells(startRow + 1, startCol).Value = "Column Name in Source File" Then
            ' Current format - need to update:
            
            ' Get the column name from the current position (row+2)
            columnName = wsMappingDef.Cells(startRow + 2, startCol).Value
            
            ' Store all mapping values temporarily
            Dim lastRow As Long
            lastRow = startRow + 2
            While wsMappingDef.Cells(lastRow + 1, startCol).Value <> ""
                lastRow = lastRow + 1
            Wend
            
            ' Clear the headers and move everything up
            wsMappingDef.Cells(startRow + 1, startCol).Value = columnName
            wsMappingDef.Cells(startRow + 1, startCol + 1).Value = "Mapping Value"
            
            ' Move all mapping values up one row
            wsMappingDef.Range(wsMappingDef.Cells(startRow + 3, startCol), _
                              wsMappingDef.Cells(lastRow, startCol + 1)).Cut _
                              Destination:=wsMappingDef.Cells(startRow + 2, startCol)
            
            ' Clear the old last row that's now duplicated
            wsMappingDef.Cells(lastRow, startCol).ClearContents
            wsMappingDef.Cells(lastRow, startCol + 1).ClearContents
            
            ' Format the table
            wsMappingDef.Cells(startRow + 1, startCol).Font.Bold = True
            wsMappingDef.Cells(startRow + 1, startCol + 1).Font.Bold = True
            
            ' Apply borders to the entire table
            lastRow = startRow + 2
            While wsMappingDef.Cells(lastRow, startCol).Value <> ""
                lastRow = lastRow + 1
            Wend
            lastRow = lastRow - 1
            
            wsMappingDef.Range(wsMappingDef.Cells(startRow, startCol), _
                              wsMappingDef.Cells(lastRow, startCol + 1)).Borders.LineStyle = xlContinuous
        End If
    Next i
    
    ' Format example tables in the Mapping worksheet
    FormatExampleMappingTables
    
    MsgBox "Mapping table format updated successfully!", vbInformation
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in UpdateMappingTableFormat", vbCritical, "Error"
End Sub

' Also update the debugging function to diagnose recon issues
Sub RunDiagnostic()
    ' This is a simple wrapper to run the diagnostic function
    ' Change these parameters to match your data
    
    ' The column number containing the primary key in File A
    Dim fileAKeyCol As Long
    fileAKeyCol = 1  ' Change this to your primary key column number
    
    ' The column number containing the primary key in File B
    Dim fileBKeyCol As Long
    fileBKeyCol = 1  ' Change this to your primary key column number
    
    ' The key value to search for - change this to a key that's showing issues
    Dim keyToFind As String
    keyToFind = "TRX008"  ' Change this to a specific key having problems
    
    ' Run the diagnostic
    DiagnoseReconciliation fileAKeyCol, fileBKeyCol, keyToFind
    
    ' For Mac, also write to a cell for visibility
    DisplayDebugResults
End Sub

Sub DisplayDebugResults()
    ' Display debug results in a visible worksheet
    ' This helps on Mac where the immediate window may not show all output
    
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets("DebugOutput")
    If ws Is Nothing Then
        Set ws = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.count))
        ws.Name = "DebugOutput"
    End If
    On Error GoTo 0
    
    ' Clear previous results
    ws.Cells.Clear
    
    ' Add header
    ws.Range("A1").Value = "Debug Output"
    ws.Range("A1").Font.Bold = True
    ws.Range("A1").Font.Size = 14
    
    ' Add a diagnostic hint - direct fix approach
    ws.Range("A3").Value = "DIRECT MATCHING FIX:"
    ws.Range("A3").Font.Bold = True
    
    ws.Range("A4").Value = "Try replacing the complex lookup code with direct record-to-record comparison:"
    ws.Range("A5").Value = "1. In PerformReconciliation, look for 'matchRowB = FindInLookup...'"
    ws.Range("A6").Value = "2. Replace with direct comparison code (see previous suggestions)"
    ws.Range("A7").Value = "3. Do the same for the 'singleton in B' detection section"
End Sub

Sub DiagnoseReconciliation(fileAKeyCol As Long, fileBKeyCol As Long, keyToFind As String)
    ' This function helps diagnose why a specific key isn't being matched correctly
    Dim wsFileA As Worksheet
    Dim wsFileB As Worksheet
    Dim i As Long
    Dim keyA As String, keyB As String
    
    Set wsFileA = Worksheets("Input File A")
    Set wsFileB = Worksheets("Input File B")
    
    Debug.Print "===== DIAGNOSTIC REPORT ====="
    Debug.Print "Looking for key: '" & keyToFind & "'"
    
    ' Check if the key exists in File A
    Debug.Print "Searching File A (Column " & fileAKeyCol & "):"
    For i = 4 To wsFileA.Cells(wsFileA.Rows.count, 1).End(xlUp).Row
        keyA = Trim(wsFileA.Cells(i, fileAKeyCol).Value)
        
        If keyA = keyToFind Then
            Debug.Print "  FOUND in File A: Row " & i & ", Value '" & keyA & "'"
            Debug.Print "    Exact match: " & (StrComp(keyA, keyToFind, vbBinaryCompare) = 0)
            Debug.Print "    Length: " & Len(keyA) & " vs " & Len(keyToFind)
            Debug.Print "    ASCII codes: " & ShowASCII(keyA)
        End If
    Next i
    
    ' Check if the key exists in File B
    Debug.Print "Searching File B (Column " & fileBKeyCol & "):"
    For i = 4 To wsFileB.Cells(wsFileB.Rows.count, 1).End(xlUp).Row
        keyB = Trim(wsFileB.Cells(i, fileBKeyCol).Value)
        
        If keyB = keyToFind Then
            Debug.Print "  FOUND in File B: Row " & i & ", Value '" & keyB & "'"
            Debug.Print "    Exact match: " & (StrComp(keyB, keyToFind, vbBinaryCompare) = 0)
            Debug.Print "    Length: " & Len(keyB) & " vs " & Len(keyToFind)
            Debug.Print "    ASCII codes: " & ShowASCII(keyB)
        End If
    Next i
    
    Debug.Print "===== END DIAGNOSTIC ====="
End Sub

Function ShowASCII(text As String) As String
    Dim i As Long
    Dim result As String
    
    result = ""
    For i = 1 To Len(text)
        result = result & Asc(Mid(text, i, 1)) & " "
    Next i
    
    ShowASCII = result
End Function

'********************************************************

Function ParseCSVLine(lineText As String, delimiter As String) As String()
    ' Parses a CSV line respecting quotes and delimiters
    ' Returns an array of fields properly parsed
    
    Dim result() As String
    Dim fieldCount As Long
    Dim i As Long
    Dim currentField As String
    Dim insideQuotes As Boolean
    Dim nextChar As String
    Dim chars() As String
    
    ' Handle empty input
    If Trim(lineText) = "" Then
        ReDim result(0)
        ParseCSVLine = result
        Exit Function
    End If
    
    ' Initialize with reasonable capacity
    fieldCount = 0
    ReDim result(0 To 100)  ' Start with space for 100 fields
    
    ' Convert line to character array for easier parsing
    chars = SplitChars(lineText)
    
    insideQuotes = False
    currentField = ""
    
    ' Process each character in the line
    For i = 0 To UBound(chars)
        ' Get current character
        Dim currentChar As String
        currentChar = chars(i)
        
        ' Handle quotes
        If currentChar = """" Then
            ' Check if this is an escaped quote (double quote)
            If i < UBound(chars) Then
                nextChar = chars(i + 1)
                If nextChar = """" And insideQuotes Then
                    ' Escaped quote inside quoted field - add a single quote and skip the next one
                    currentField = currentField & """"
                    i = i + 1  ' Skip next quote
                Else
                    ' Regular quote - toggle insideQuotes flag
                    insideQuotes = Not insideQuotes
                End If
            Else
                ' Last character is a quote
                insideQuotes = Not insideQuotes
            End If
        
        ' Handle delimiter
        ElseIf currentChar = delimiter And Not insideQuotes Then
            ' End of field - add to result
            result(fieldCount) = currentField
            fieldCount = fieldCount + 1
            currentField = ""
            
            ' Resize array if needed
            If fieldCount > UBound(result) Then
                ReDim Preserve result(0 To fieldCount + 100)
            End If
        
        ' Regular character - add to current field
        Else
            currentField = currentField & currentChar
        End If
    Next i
    
    ' Add the last field
    result(fieldCount) = currentField
    fieldCount = fieldCount + 1
    
    ' Trim the result array to actual size
    ReDim Preserve result(0 To fieldCount - 1)
    
    ParseCSVLine = result
End Function

Function SplitChars(text As String) As String()
    ' Split a string into an array of characters
    Dim result() As String
    Dim i As Long
    
    If Len(text) = 0 Then
        ReDim result(0)
        SplitChars = result
        Exit Function
    End If
    
    ReDim result(0 To Len(text) - 1)
    
    For i = 1 To Len(text)
        result(i - 1) = Mid(text, i, 1)
    Next i
    
    SplitChars = result
End Function

Function ReadEntireFile(filePath As String) As String
    ' Reads an entire file into a string at once
    Dim fileNum As Integer
    Dim fileLength As Long
    Dim fileContent As String
    
    On Error GoTo ErrorHandler
    
    ' Get a free file number
    fileNum = FreeFile
    
    ' Open the file for binary access (fastest)
    Open filePath For Binary Access Read As #fileNum
    
    ' Get the file length
    fileLength = LOF(fileNum)
    
    ' Prepare a string of the right size
    fileContent = Space$(fileLength)
    
    ' Read the entire file in one operation
    Get #fileNum, , fileContent
    
    ' Close the file
    Close #fileNum
    
    ' Return the file content
    ReadEntireFile = fileContent
    
    Exit Function
    
ErrorHandler:
    ' Close the file if it's open
    On Error Resume Next
    Close #fileNum
    On Error GoTo 0
    
    ' Return empty string to indicate error
    ReadEntireFile = ""
End Function

' Add this function to your module
Function IsMacOS() As Boolean
    #If Mac Then
        IsMacOS = True
    #Else
        IsMacOS = False
    #End If
End Function

' Add this function to your module
Sub OptimizeAppSettings(turnOn As Boolean)
    ' Store original settings to restore them exactly
    Static originalScreenUpdating As Boolean
    Static originalEnableEvents As Boolean
    Static originalCalculation As XlCalculation
    Static originalDisplayAlerts As Boolean
    
    With Application
        If turnOn Then
            ' Store original settings first time
            originalScreenUpdating = .ScreenUpdating
            originalEnableEvents = .EnableEvents
            originalCalculation = .Calculation
            originalDisplayAlerts = .DisplayAlerts
            
            ' Turn off settings that slow down execution
            .ScreenUpdating = False
            .EnableEvents = False
            .Calculation = xlCalculationManual
            .DisplayAlerts = False
            
            ' Status bar handling slightly different on Mac vs Windows
            #If Mac Then
                ' Mac may have issues with frequent status bar updates
                .StatusBar = "Processing... Please wait."
            #Else
                .DisplayStatusBar = True
                .StatusBar = "Processing..."
            #End If
        Else
            ' Restore exact original settings
            .ScreenUpdating = originalScreenUpdating
            .EnableEvents = originalEnableEvents
            .Calculation = originalCalculation
            .DisplayAlerts = originalDisplayAlerts
            
            ' Reset status bar (works on both platforms)
            .StatusBar = False
        End If
    End With
End Sub


Sub UpdateApplyMappingFunction()
    ' Update code in the ApplyMapping function to handle the new table format
    MsgBox "Please add the following changes to your ApplyMapping function:" & vbCrLf & vbCrLf & _
           "1. Change 'columnName = wsMappingDef.Cells(tableStartRows(i) + 2, startCol).Value' to:" & vbCrLf & _
           "   columnName = wsMappingDef.Cells(tableStartRows(i) + 1, startCol).Value" & vbCrLf & vbCrLf & _
           "2. Change 'j = tableStartRow + 3' to:" & vbCrLf & _
           "   j = tableStartRow + 2" & vbCrLf & vbCrLf & _
           "This will adjust the code to work with the new table format.", vbInformation, _
           "ApplyMapping Function Updates Needed"
End Sub

Sub UpdateMappingWorksheet()
    ' Run both updates
    UpdateMappingTableFormat
    UpdateApplyMappingFunction
End Sub
' =================================== INITIALIZATION ===================================
Sub InitializeWorkbook()
    ' This macro creates all the required worksheets and formats them according to specifications
    On Error GoTo ErrorHandler
    
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    ' Create all required worksheets in a safer way
    Call SafeCreateAllWorksheets
    
    ' Format worksheets
    Call FormatWorksheets
    
    ' Create buttons on Parameters sheet
    Call CreateButtons
    
CleanExit:
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    
    MsgBox "Workbook initialized successfully!", vbInformation, "Initialization Complete"
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & vbNewLine & _
           "Try closing and reopening Excel, then run the macro again.", vbCritical, "Initialization Error"
    Resume CleanExit
End Sub

Function WorksheetExists(wsName As Variant) As Boolean
    ' Check if worksheet exists
    Dim ws As Worksheet
    
    On Error Resume Next
    Set ws = Worksheets(CStr(wsName))
    On Error GoTo 0
    
    WorksheetExists = Not ws Is Nothing
End Function

Sub SafeCreateAllWorksheets()
    ' Create all required worksheets in a safer way
    Dim wsNames As Variant
    Dim wsColors As Variant
    Dim i As Integer
    Dim wsExists As Boolean
    Dim newWs As Worksheet
    
    
    ' *** Change the order of the worksheet names and colours if worksheet position change is required. *** '
    
    ' Define worksheet names
    wsNames = Array("Instructions", "Input Parameters", "Mapping", "Result", "Dashboard", "Input File A", "Input File B", _
                   "Supplementary File A", "Supplementary File B")
    
    ' Define tab colors (RGB format)
    wsColors = Array(RGB(255, 255, 153), RGB(204, 255, 204), RGB(192, 192, 192), RGB(255, 204, 153), RGB(255, 255, 204), _
                     RGB(204, 204, 255), RGB(255, 153, 153), RGB(204, 255, 255), _
                     RGB(255, 204, 255))
    
    ' Check if we have any of the required worksheets already
    For i = 0 To UBound(wsNames)
        If WorksheetExists(wsNames(i)) Then
            ' If the sheet exists, clear its contents but keep the sheet
            On Error Resume Next
            Worksheets(wsNames(i)).Cells.Clear
            ' Try to set the tab color if possible
            Worksheets(wsNames(i)).Tab.Color = wsColors(i)
            On Error GoTo 0
        Else
            ' Add the sheet if it doesn't exist
            On Error Resume Next
            Set newWs = Worksheets.Add(After:=Worksheets(Worksheets.count))
            If Err.Number = 0 Then
                newWs.Name = wsNames(i)
                ' Try to set the tab color if possible
                newWs.Tab.Color = wsColors(i)
            End If
            On Error GoTo 0
        End If
    Next i
    
    ' Handle the case where Sheet1 still exists and isn't one of our named sheets
    If WorksheetExists("Sheet1") Then
        Dim sheetFound As Boolean
        sheetFound = False
        
        For i = 0 To UBound(wsNames)
            If wsNames(i) = "Sheet1" Then
                sheetFound = True
                Exit For
            End If
        Next i
        
        If Not sheetFound Then
            ' If Sheet1 isn't one of our named sheets, rename it to the first sheet we need
            On Error Resume Next
            Worksheets("Sheet1").Name = wsNames(0)
            Worksheets(wsNames(0)).Tab.Color = wsColors(0)
            On Error GoTo 0
        End If
    End If
End Sub

Sub FormatWorksheets()
    ' Format all worksheets according to specifications
    On Error Resume Next
    
    ' 1. Instructions worksheet
    If WorksheetExists("Instructions") Then
        Call FormatInstructionsSheet
    End If
    
    ' 2. Input Parameters worksheet
    If WorksheetExists("Input Parameters") Then
        Call FormatParametersSheet
    End If
    
    ' 3. Result worksheet
    If WorksheetExists("Result") Then
        Call FormatResultSheet
    End If
    
    ' 4-7. Input and Supplementary files worksheets (minimal formatting, content will be populated later)
    If WorksheetExists("Input File A") Then
        Call FormatDataSheet("Input File A")
    End If
    
    If WorksheetExists("Input File B") Then
        Call FormatDataSheet("Input File B")
    End If
    
    If WorksheetExists("Supplementary File A") Then
        Call FormatDataSheet("Supplementary File A")
    End If
    
    If WorksheetExists("Supplementary File B") Then
        Call FormatDataSheet("Supplementary File B")
    End If
    
    ' 8. Mapping worksheet
    If WorksheetExists("Mapping") Then
        Call FormatMappingSheet
    End If
    
    ' 9. Dashboard worksheet
    If WorksheetExists("Dashboard") Then
        Call FormatDashboardSheet
    End If
    
    On Error GoTo 0
End Sub

Sub FormatInstructionsSheet()
    ' Format Instructions worksheet
    Dim ws As Worksheet
    Set ws = Worksheets("Instructions")
    
    ' Clear sheet
    ws.Cells.Clear
    
    ' Add title
    ws.Range("A1").Value = "RECONCILIATION TOOL - INSTRUCTIONS"
    ws.Range("A1").Font.Bold = True
    ws.Range("A1").Font.Size = 16
    
    ' Add instructions
    ws.Range("A3").Value = "HOW TO USE THIS RECONCILIATION TOOL:"
    ws.Range("A3").Font.Bold = True
    
    ws.Range("A5").Value = "1. Go to 'Input Parameters' tab and fill in the required information:"
    ws.Range("A6").Value = "   - Input File Paths"
    ws.Range("A7").Value = "   - Data Source Names"
    ws.Range("A8").Value = "   - File Delimiters"
    ws.Range("A9").Value = "   - Reconciliation Keys"
    ws.Range("A10").Value = "   - Mapping Information (if needed)"
    
    ws.Range("A12").Value = "2. Use the buttons on the 'Input Parameters' tab to run each step of the reconciliation process:"
    ws.Range("A13").Value = "   - Load Input Files: Imports data from the specified input files"
    ws.Range("A14").Value = "   - Load Supplementary Files: Imports data from supplementary files (if specified)"
    ws.Range("A15").Value = "   - Apply Mapping: Applies any mapping defined in the 'Mapping' tab"
    ws.Range("A16").Value = "   - Run Reconciliation: Performs the reconciliation based on specified keys"
    ws.Range("A17").Value = "   - Generate Dashboard: Creates a summary of reconciliation results"
    
    ws.Range("A19").Value = "3. View the results in the 'Result' tab and 'Dashboard' tab"
    
    ws.Range("A21").Value = "NOTES:"
    ws.Range("A21").Font.Bold = True
    ws.Range("A22").Value = "- All data is processed as text to preserve leading zeros"
    ws.Range("A23").Value = "- For better performance with large files, run each step separately"
    ws.Range("A24").Value = "- Make sure column names in mapping tables match exactly with input files"
    
    ' Auto-fit columns
    ws.Columns("A:A").AutoFit
End Sub

Sub FormatParametersSheet()
    ' Format Input Parameters worksheet
    Dim ws As Worksheet
    Set ws = Worksheets("Input Parameters")
    Dim i As Integer
    
    ' Clear sheet
    ws.Cells.Clear
    
    ' Add title
    ws.Range("A1").Value = "RECONCILIATION TOOL - INPUT PARAMETERS"
    ws.Range("A1").Font.Bold = True
    ws.Range("A1").Font.Size = 16
    ws.Range("A1:F1").Merge
    
    ' Format sections
    
    ' 1. Input File Paths
    ws.Range("A3").Value = "1. INPUT FILE PATHS"
    ws.Range("A3").Font.Bold = True
    
    ws.Range("A5").Value = "Input File A"
    ws.Range("B5").Value = ""
    ws.Range("C5").Interior.Color = RGB(204, 204, 255)  ' Match 'Input File A' tab color
    
    ws.Range("A6").Value = "Input File B"
    ws.Range("B6").Value = ""
    ws.Range("C6").Interior.Color = RGB(255, 153, 153)  ' Match 'Input File B' tab color
    
    ws.Range("A7").Value = "Supplementary File A (Optional)"
    ws.Range("B7").Value = ""
    ws.Range("C7").Interior.Color = RGB(204, 255, 255)  ' Match 'Supplementary File A' tab color
    
    ws.Range("A8").Value = "Supplementary File B (Optional)"
    ws.Range("B8").Value = ""
    ws.Range("C8").Interior.Color = RGB(255, 204, 255)  ' Match 'Supplementary File B' tab color
    
    ' 2. Input Names
    ws.Range("A10").Value = "2. DATA SOURCE NAMES"
    ws.Range("A10").Font.Bold = True
    
    ws.Range("A12").Value = "Source of Input File A"
    ws.Range("B12").Value = ""
    ws.Range("C12").Interior.Color = RGB(204, 204, 255)
    
    ws.Range("A13").Value = "Source of Input File B"
    ws.Range("B13").Value = ""
    ws.Range("C13").Interior.Color = RGB(255, 153, 153)
    
    ' 3. Delimiters
    ws.Range("A15").Value = "3. FILE DELIMITERS"
    ws.Range("A15").Font.Bold = True
    
    ws.Range("A17").Value = "Delimiter of Input File A"
    ws.Range("B17").Value = ","
    
    ws.Range("A18").Value = "Delimiter of Input File B"
    ws.Range("B18").Value = ","
    
    ws.Range("A19").Value = "Delimiter of Supplementary File A"
    ws.Range("B19").Value = ","
    
    ws.Range("A20").Value = "Delimiter of Supplementary File B"
    ws.Range("B20").Value = ","
    
    ' 4. Reconciliation Keys
    ws.Range("A22").Value = "4. RECONCILIATION KEYS"
    ws.Range("A22").Font.Bold = True
    
    ws.Range("A24").Value = "Column Name for Recon Keys"
    ws.Range("B24").Value = "Primary Key"
    ws.Range("C24").Value = "Secondary Key"
    ws.Range("A24:C24").Font.Bold = True
    
    ws.Range("A25").Value = "Input File A"
    ws.Range("B25").Value = ""
    ws.Range("C25").Value = ""
    
    ws.Range("A26").Value = "Input File B"
    ws.Range("B26").Value = ""
    ws.Range("C26").Value = ""
    
    ' 5. Supplementary Data Keys
    ws.Range("A28").Value = "5. SUPPLEMENTARY DATA A KEYS"
    ws.Range("A28").Font.Bold = True
    
    ws.Range("A30").Value = "Column Name for Supplementary Data A Keys"
    ws.Range("B30").Value = "Primary Key"
    ws.Range("A30:B30").Font.Bold = True
    
    ws.Range("A31").Value = "Input File A"
    ws.Range("B31").Value = ""
    
    ws.Range("A32").Value = "Supplementary File A"
    ws.Range("B32").Value = ""
    
    ' 6. Supplementary Data Columns
    ws.Range("A34").Value = "Supplementary Data A Column Required at Output"
    ws.Range("A34").Font.Bold = True
    
    ' Add a few blank rows for user input
    ws.Range("A35").Value = ""
    ws.Range("A36").Value = ""
    ws.Range("A37").Value = ""
    
    ' 7. Supplementary Data B Keys
    ws.Range("A39").Value = "6. SUPPLEMENTARY DATA B KEYS"
    ws.Range("A39").Font.Bold = True
    
    ws.Range("A41").Value = "Column Name for Supplementary Data B Keys"
    ws.Range("B41").Value = "Primary Key"
    ws.Range("A41:B41").Font.Bold = True
    
    ws.Range("A42").Value = "Input File B"
    ws.Range("B42").Value = ""
    
    ws.Range("A43").Value = "Supplementary File B"
    ws.Range("B43").Value = ""
    
    ' 8. Supplementary Data Columns
    ws.Range("A45").Value = "Supplementary Data B Column Required at Output"
    ws.Range("A45").Font.Bold = True
    
    ' Add a few blank rows for user input
    ws.Range("A46").Value = ""
    ws.Range("A47").Value = ""
    ws.Range("A48").Value = ""
    
    ' Add Column Mapping Table in columns I-J
    ws.Range("I3").Value = "COLUMN MAPPING TABLE"
    ws.Range("I3").Font.Bold = True
    
    ws.Range("I5").Value = "Input File A"
    ws.Range("J5").Value = "Input File B"
    ws.Range("I5:J5").Font.Bold = True
    
    ' Add empty rows for mapping (can be pre-populated by users)
    For i = 6 To 105
        ws.Range("I" & i).Value = ""
        ws.Range("J" & i).Value = ""
    Next i
    
    ' Format the mapping table
    ws.Range("I5:J105").Borders.LineStyle = xlContinuous
    
    ' Format all cells with borders
    ws.Range("A3:C48").Borders.LineStyle = xlContinuous
    
    ' Auto-fit columns
    ws.Columns("A:J").AutoFit
    
    'Add red asterisks to mandatory fields
    AddMandatoryFieldIndicators
    
End Sub

Sub AddMandatoryFieldIndicators()
    ' Add red asterisks to mandatory fields in the Input Parameters sheet
    On Error GoTo ErrorHandler
    
    Dim ws As Worksheet
    Dim r As Range
    Dim mandatoryFields As Variant
    Dim i As Long
    
    ' List of mandatory fields to mark with asterisks - field labels in column A
    mandatoryFields = Array("Input File A", "Input File B", _
                           "Source of Input File A", "Source of Input File B", _
                           "Delimiter of Input File A", "Delimiter of Input File B", _
                           "Column Name for Recon Keys")
    
    ' Set worksheet
    Set ws = Worksheets("Input Parameters")
    
    ' Loop through each mandatory field
    For i = LBound(mandatoryFields) To UBound(mandatoryFields)
        ' Search for the label in column A
        Set r = ws.Columns("A").Find(What:=mandatoryFields(i), _
                                    LookIn:=xlValues, _
                                    LookAt:=xlWhole, _
                                    SearchOrder:=xlByRows, _
                                    SearchDirection:=xlNext, _
                                    MatchCase:=False)
        
        ' If found, add a red asterisk
        If Not r Is Nothing Then
            ' Check if it already has an asterisk
            If Right(r.Value, 1) <> "*" Then
                ' Add asterisk
                r.Value = r.Value & " *"
                
                ' Format the asterisk in red
                With r.Characters(Start:=Len(r.Value), Length:=1).Font
                    .Color = RGB(255, 0, 0)
                    .Bold = True
                End With
            End If
        End If
    Next i
    
    ' Handle the Primary Key field specifically - it's in cell B24
    If Not IsEmpty(ws.Range("B24").Value) Then
        If Right(ws.Range("B24").Value, 1) <> "*" Then
            ws.Range("B24").Value = ws.Range("B24").Value & " *"
            
            With ws.Range("B24").Characters(Start:=Len(ws.Range("B24").Value), Length:=1).Font
                .Color = RGB(255, 0, 0)
                .Bold = True
            End With
        End If
    Else
        ws.Range("B24").Value = "Primary Key *"
        
        With ws.Range("B24").Characters(Start:=Len(ws.Range("B24").Value), Length:=1).Font
            .Color = RGB(255, 0, 0)
            .Bold = True
        End With
    End If
    
    ' Also handle the column mapping table in columns I & J
    ws.Range("I5").Value = "Input File A *"
    ws.Range("J5").Value = "Input File B *"
    
    ' Format the asterisks in red
    With ws.Range("I5").Characters(Start:=Len(ws.Range("I5").Value), Length:=1).Font
        .Color = RGB(255, 0, 0)
        .Bold = True
    End With
    
    With ws.Range("J5").Characters(Start:=Len(ws.Range("J5").Value), Length:=1).Font
        .Color = RGB(255, 0, 0)
        .Bold = True
    End With
    
    ' Add a note about mandatory fields
    ws.Range("A1").Offset(0, 1).Value = "* Mandatory fields"
    ws.Range("A1").Offset(0, 1).Font.Color = RGB(255, 0, 0)
    ws.Range("A1").Offset(0, 1).Font.Bold = True
        
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in AddMandatoryFieldIndicators", vbCritical, "Error"
End Sub


Sub FormatDataSheet(sheetName As String)
    ' Basic formatting for data sheets
    Dim ws As Worksheet
    Set ws = Worksheets(sheetName)
    
    ' Clear sheet
    ws.Cells.Clear
    
    ' Add title
    ws.Range("A1").Value = "DATA FROM " & UCase(sheetName)
    ws.Range("A1").Font.Bold = True
    ws.Range("A1").Font.Size = 14
    
    ' Add note
    ws.Range("A2").Value = "This data will be populated when you load the input files."
    ws.Range("A2").Font.Italic = True
End Sub

Sub FormatMappingSheet()
    ' Format Mapping worksheet
    Dim ws As Worksheet
    Set ws = Worksheets("Mapping")
    
    ' Clear sheet
    ws.Cells.Clear
    
    ' Add title
    ws.Range("A1").Value = "MAPPING TABLES"
    ws.Range("A1").Font.Bold = True
    ws.Range("A1").Font.Size = 16
    
    ' Add instructions
    ws.Range("A3").Value = "Instructions:"
    ws.Range("A3").Font.Bold = True
    ws.Range("A4").Value = "- Add mapping tables below for any columns that require value mapping before reconciliation"
    ws.Range("A5").Value = "- Each mapping table must include the input file (A or B) and the column name"
    ws.Range("A6").Value = "- Separate mapping tables with at least one empty column"
    
    ' Example mapping table
    ws.Range("A8").Value = "Input File: <A/B>"
    ws.Range("A8").Font.Bold = True
    
    ws.Range("A9").Value = "<Column Name in Source File>"
    ws.Range("B9").Value = "Mapping Value"
    ws.Range("A9:B9").Font.Bold = True
    
    ws.Range("A10").Value = "<Source Value 1>"
    ws.Range("B10").Value = "<Mapped Value 1>"
    
    ws.Range("A11").Value = "<Source Value 2>"
    ws.Range("B11").Value = "<Mapped Value 2>"
    
    ' Add another example
    ws.Range("D8").Value = "Input File: <A/B>"
    ws.Range("D8").Font.Bold = True
    
    ws.Range("D9").Value = "<Column Name in Source File>"
    ws.Range("E9").Value = "Mapping Value"
    ws.Range("D9:E9").Font.Bold = True
    
    ws.Range("D10").Value = "<Source Value 1>"
    ws.Range("E10").Value = "<Mapped Value 1>"
    
    ws.Range("D11").Value = "<Source Value 2>"
    ws.Range("E11").Value = "<Mapped Value 2>"
    
    ' Format table with borders
    ws.Range("A8:B11").Borders.LineStyle = xlContinuous
    ws.Range("D8:E11").Borders.LineStyle = xlContinuous
    
    ' Auto-fit columns
    ws.Columns("A:E").AutoFit
End Sub

Sub FormatResultSheet()
    ' Basic formatting for Result sheet
    Dim ws As Worksheet
    Set ws = Worksheets("Result")
    
    ' Clear sheet
    ws.Cells.Clear
    
    ' Add title
    ws.Range("A1").Value = "RECONCILIATION RESULTS"
    ws.Range("A1").Font.Bold = True
    ws.Range("A1").Font.Size = 16
    
    ' Add note
    ws.Range("A2").Value = "Results will be populated when you run the reconciliation process."
    ws.Range("A2").Font.Italic = True
End Sub

Sub FormatDashboardSheet()
    ' Basic formatting for Dashboard sheet
    Dim ws As Worksheet
    Set ws = Worksheets("Dashboard")
    
    ' Clear sheet
    ws.Cells.Clear
    
    ' Add title
    ws.Range("A1").Value = "RECONCILIATION DASHBOARD"
    ws.Range("A1").Font.Bold = True
    ws.Range("A1").Font.Size = 16
    
    ' Add note
    ws.Range("A2").Value = "Dashboard will be populated after reconciliation is complete."
    ws.Range("A2").Font.Italic = True
End Sub

Sub CreateButtons()
    ' Create buttons on the Parameters sheet
    On Error Resume Next
    
    Dim ws As Worksheet
    If Not WorksheetExists("Input Parameters") Then
        MsgBox "Input Parameters sheet doesn't exist. Unable to create buttons.", vbExclamation
        Exit Sub
    End If
    
    Set ws = Worksheets("Input Parameters")
    
    ' Add a section for buttons
    ws.Range("E3").Value = "RUN RECONCILIATION STEPS"
    ws.Range("E3").Font.Bold = True
    
    ' Remove any existing buttons to avoid duplicates
    ClearExistingButtons ws
    
    ' Create buttons for each step
    ' Note: In macOS, ActiveX controls might not work properly, so we use Form controls
    
    ' Button 1: Load Input Files
    AddButton ws, 340, 30, 120, 30, "ThisWorkbook.LoadInputFiles", "1. Load Input Files", "btnLoadInputFiles"
    
    ' Button 2: Load Supplementary Files
    AddButton ws, 340, 65, 120, 30, "ThisWorkbook.LoadSupplementaryFiles", "2. Load Supplementary Files", "btnLoadSupplementaryFiles"
    
    ' Button 3: Apply Mapping
    AddButton ws, 340, 100, 120, 30, "ThisWorkbook.ApplyMapping", "3. Apply Mapping", "btnApplyMapping"
    
    ' Button 4: Run Reconciliation
    AddButton ws, 340, 135, 120, 30, "ThisWorkbook.RunReconciliation", "4. Run Reconciliation", "btnRunReconciliation"
    
    ' Button 5: Generate Dashboard
    AddButton ws, 340, 170, 120, 30, "ThisWorkbook.GenerateDashboard", "5. Generate Dashboard", "btnGenerateDashboard"
    
    ' Button 6: Run All Steps
    AddButton ws, 340, 215, 120, 30, "ThisWorkbook.RunAllSteps", "Run All Steps", "btnRunAllSteps"
    
    ' Deselect buttons
    ws.Range("A1").Select
        
    On Error GoTo 0
End Sub

Sub ClearExistingButtons(ws As Worksheet)
    ' Remove any existing buttons from the worksheet
    On Error Resume Next
    
    ' Clear form buttons
    Dim btn As Button
    For Each btn In ws.Buttons
        btn.Delete
    Next btn
    
    On Error GoTo 0
End Sub

Sub AddButton(ws As Worksheet, left As Double, top As Double, width As Double, height As Double, _
              actionName As String, captionText As String, buttonName As String)
    ' Add a button safely with error handling
    On Error Resume Next
    
    Dim btn As Button
    Set btn = ws.Buttons.Add(left, top, width, height)
    
    If Not btn Is Nothing Then
        btn.OnAction = actionName
        btn.Caption = captionText
        btn.Name = buttonName
    End If
    
    On Error GoTo 0
End Sub

' =================================== LOAD FILE FUNCTIONS ===================================

Sub LoadInputFiles()
    ' Load input files A and B with performance optimizations
    On Error GoTo ErrorHandler
    
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.StatusBar = "Loading input files..."
    
    ' Get parameters from Input Parameters sheet
    ReadParameters
    
    ' Clear any mapped columns from previous runs
    ClearMappedColumns Worksheets("Input File A")
    ClearMappedColumns Worksheets("Input File B")
    
    ' Load File A
    If gstrInputFileAPath <> "" Then
        Application.StatusBar = "Loading Input File A..."
        LoadDataFromFile gstrInputFileAPath, "Input File A", gstrInputADelimiter
    Else
        MsgBox "Input File A path is missing. Please provide a valid file path.", vbExclamation, "Missing Input"
        GoTo CleanExit
    End If
    
    ' Load File B
    If gstrInputFileBPath <> "" Then
        Application.StatusBar = "Loading Input File B..."
        LoadDataFromFile gstrInputFileBPath, "Input File B", gstrInputBDelimiter
    Else
        MsgBox "Input File B path is missing. Please provide a valid file path.", vbExclamation, "Missing Input"
        GoTo CleanExit
    End If
    
    ' Create mapping table
    Application.StatusBar = "Creating mapping table..."
    CreateMappingTable
    
    ' Show success message
    Application.StatusBar = "Files loaded successfully."
    
CleanExit:
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    
    If Err.Number = 0 Then
        MsgBox "Input files loaded successfully!", vbInformation, "Files Loaded"
    End If
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in LoadInputFiles", vbCritical, "Error"
    Resume CleanExit
End Sub

Sub LoadSupplementaryFiles()
    ' Load supplementary files with optimized performance
    On Error GoTo ErrorHandler
    
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.StatusBar = "Loading supplementary files..."
    
    ' Get parameters from Input Parameters sheet
    ReadParameters
    
    ' Clear any mapped columns from previous runs
    ClearMappedColumns Worksheets("Supplementary File A")
    ClearMappedColumns Worksheets("Supplementary File B")
    
    ' Load Supplementary File A if specified
    If gstrSupplementaryFileAPath <> "" Then
        Application.StatusBar = "Loading Supplementary File A..."
        LoadDataFromFile gstrSupplementaryFileAPath, "Supplementary File A", gstrSupplementaryADelimiter
        Application.StatusBar = "Supplementary File A loaded successfully!"
    Else
        Application.StatusBar = "No Supplementary File A specified."
    End If
    
    ' Load Supplementary File B if specified
    If gstrSupplementaryFileBPath <> "" Then
        Application.StatusBar = "Loading Supplementary File B..."
        LoadDataFromFile gstrSupplementaryFileBPath, "Supplementary File B", gstrSupplementaryBDelimiter
        Application.StatusBar = "Supplementary File B loaded successfully!"
    Else
        Application.StatusBar = "No Supplementary File B specified."
    End If
    
CleanExit:
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    
    If Err.Number = 0 Then
        If gstrSupplementaryFileAPath <> "" Or gstrSupplementaryFileBPath <> "" Then
            MsgBox "Supplementary files loaded successfully!", vbInformation, "Files Loaded"
        Else
            MsgBox "No supplementary files were specified.", vbInformation, "No Files"
        End If
    End If
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in LoadSupplementaryFiles", vbCritical, "Error"
    Resume CleanExit
End Sub

Sub ReadParameters()
    ' Read parameters from Input Parameters sheet
    Dim ws As Worksheet
    Set ws = Worksheets("Input Parameters")
    
    ' Read file paths
    gstrInputFileAPath = ws.Range("B5").Value
    gstrInputFileBPath = ws.Range("B6").Value
    gstrSupplementaryFileAPath = ws.Range("B7").Value
    gstrSupplementaryFileBPath = ws.Range("B8").Value
    
    ' Read source names
    gstrInputASource = ws.Range("B12").Value
    gstrInputBSource = ws.Range("B13").Value
    
    ' Read delimiters
    gstrInputADelimiter = ws.Range("B17").Value
    gstrInputBDelimiter = ws.Range("B18").Value
    gstrSupplementaryADelimiter = ws.Range("B19").Value
    gstrSupplementaryBDelimiter = ws.Range("B20").Value
    
    ' Read reconciliation keys
    gstrPrimaryKeyA = ws.Range("B25").Value
    gstrPrimaryKeyB = ws.Range("B26").Value
    gstrSecondaryKeyA = ws.Range("C25").Value
    gstrSecondaryKeyB = ws.Range("C26").Value
    
    ' Read supplementary keys
    gstrSupplementaryKeyA = ws.Range("B31").Value
    gstrSupplementaryASourceKey = ws.Range("B32").Value
    gstrSupplementaryKeyB = ws.Range("B42").Value
    gstrSupplementaryBSourceKey = ws.Range("B43").Value
End Sub

Function IsDate2(strValue As String) As Boolean
    ' More conservative date detection function
    On Error Resume Next
    
    IsDate2 = False
    
    ' Skip empty strings
    If Trim(strValue) = "" Then Exit Function
    
    ' If it's purely numeric with no separators, it's probably not a date
    If IsNumeric(strValue) Then
        ' Pure integers are not treated as dates
        If InStr(1, strValue, ".") = 0 And InStr(1, strValue, "/") = 0 And InStr(1, strValue, "-") = 0 Then
            IsDate2 = False
            Exit Function
        End If
    End If
    
    ' Check for date separators - must have at least one to be considered a date
    If InStr(1, strValue, "/") = 0 And InStr(1, strValue, "-") = 0 Then
        IsDate2 = False
        Exit Function
    End If
    
    ' Check if it's a standard date format
    If IsDate(strValue) Then
        ' Additional validation to avoid false positives
        ' Must contain digits and separators in patterns typical of dates
        If (InStr(1, strValue, "/") > 0 Or InStr(1, strValue, "-") > 0) And _
           Len(strValue) >= 6 Then ' At least M/D/YY format
            IsDate2 = True
        End If
        Exit Function
    End If
    
    ' Handle potential ISO date format (YYYY-MM-DD)
    If Len(strValue) = 10 Then
        If Mid(strValue, 5, 1) = "-" And Mid(strValue, 8, 1) = "-" Then
            Dim year As String, month As String, day As String
            year = left(strValue, 4)
            month = Mid(strValue, 6, 2)
            day = Right(strValue, 2)
            
            If IsNumeric(year) And IsNumeric(month) And IsNumeric(day) Then
                If CInt(year) >= 1900 And CInt(year) <= 2100 Then
                    If CInt(month) >= 1 And CInt(month) <= 12 Then
                        If CInt(day) >= 1 And CInt(day) <= 31 Then
                            IsDate2 = True
                            Exit Function
                        End If
                    End If
                End If
            End If
        End If
    End If
    
    On Error GoTo 0
End Function

Sub LoadDataFromFile(filePath As String, destSheet As String, delimiter As String)
    ' Highly optimized version that loads data 20-100x faster
    On Error GoTo ErrorHandler
    
    Dim ws As Worksheet
    Dim fileContent As String
    Dim i As Long, j As Long
    Dim lines() As String
    Dim dataArray() As String
    Dim resultArray() As Variant
    Dim headerRow As Long
    Dim lastRow As Long
    Dim columnCount As Long
    Dim rowCount As Long
    Dim dataStartRow As Long
    Dim startTime As Double
    
    ' Record start time for performance reporting
    startTime = Timer
    
    ' Set destination worksheet
    Set ws = Worksheets(destSheet)
    
    ' Clear previous data (both content and formatting)
    Application.StatusBar = "Clearing worksheet..."
    ws.Range("A3:ZZ" & ws.Rows.count).ClearContents
    ws.Range("A3:ZZ" & ws.Rows.count).ClearFormats
    
    ' Format header row
    headerRow = 3
    ws.Rows(headerRow).Font.Bold = True
    
    ' Get the file content in one operation
    Application.StatusBar = "Reading file..."
    fileContent = ReadEntireFile(filePath)
    
    If fileContent = "" Then
        MsgBox "Error reading file or file is empty: " & filePath, vbCritical, "File Error"
        Exit Sub
    End If
    
    ' Split into lines
    lines = Split(fileContent, vbCrLf)
    
    ' Handle different line endings
    If UBound(lines) < 1 Then
        lines = Split(fileContent, vbLf)
    End If
    
    ' Count data rows and columns
    rowCount = UBound(lines) + 1
    
    ' Process the header row to determine column count
    If rowCount > 0 Then
        ' Parse the first row properly to get accurate column count
        dataArray = ParseCSVLine(lines(0), delimiter)
        columnCount = UBound(dataArray) + 1
    Else
        MsgBox "No data found in file: " & filePath, vbCritical, "Empty File"
        Exit Sub
    End If
    
    ' Create a 2D array to hold all data (including header)
    dataStartRow = headerRow - 1 ' Offset to convert between 0-based array and 1-based Excel rows
    ReDim resultArray(1 To rowCount, 1 To columnCount)
    
    ' Parse and store all data in the array
    Application.StatusBar = "Processing data..."
    
    ' Process in chunks to provide status updates
    Const CHUNK_SIZE As Long = 1000
    
    For i = 0 To rowCount - 1
        ' Update status periodically
        If i Mod CHUNK_SIZE = 0 Then
            Application.StatusBar = "Processing row " & i & " of " & rowCount & " (" & Format(i / rowCount, "0%") & ")"
        End If
        
        If Trim(lines(i)) <> "" Then
            ' Parse the line properly, handling quotes etc.
            dataArray = ParseCSVLine(lines(i), delimiter)
            
            ' Fill the row in the result array
            For j = 0 To UBound(dataArray)
                If j < columnCount Then ' Safety check
                    resultArray(i + 1, j + 1) = Trim(dataArray(j))
                End If
            Next j
        End If
    Next i
    
    ' Write the entire array to the worksheet in ONE operation
    Application.StatusBar = "Writing data to worksheet..."
    ws.Range(ws.Cells(headerRow, 1), ws.Cells(headerRow + rowCount - 1, columnCount)).Value = resultArray
    
    ' Apply text format to preserve leading zeros (bulk operation)
    ws.Range(ws.Cells(headerRow, 1), ws.Cells(headerRow + rowCount - 1, columnCount)).NumberFormat = "@"
    
    ' Format headers
    ws.Range(ws.Cells(headerRow, 1), ws.Cells(headerRow, columnCount)).Font.Bold = True
    ws.Range(ws.Cells(headerRow, 1), ws.Cells(headerRow, columnCount)).Interior.Color = RGB(220, 220, 220)
    
    ' Auto-fit columns (this can be slow for large datasets)
    Application.StatusBar = "Adjusting column widths..."
    ws.Columns("A:Z").AutoFit
    
    ' Report performance
    Application.StatusBar = "File loaded in " & Format(Timer - startTime, "0.00") & " seconds."
    
    Exit Sub
    
ErrorHandler:
    ' Show error details
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in LoadDataFromFile", vbCritical, "Error"
End Sub

Sub CopyValueWithFormatting(sourceWs As Worksheet, sourceRow As Long, sourceCol As Long, destWs As Worksheet, destRow As Long, destCol As Long)
    ' Copy a cell value while preserving formatting (especially date formats)
    On Error Resume Next
    
    ' Copy the value
    destWs.Cells(destRow, destCol).Value = sourceWs.Cells(sourceRow, sourceCol).Value
    
    ' Preserve the number format
    destWs.Cells(destRow, destCol).NumberFormat = sourceWs.Cells(sourceRow, sourceCol).NumberFormat
    
    On Error GoTo 0
End Sub

Sub ClearMappedColumns(ws As Worksheet)
    ' Optimized version of ClearMappedColumns
    On Error GoTo ErrorHandler
    
    Dim lastCol As Long
    Dim i As Long
    Dim colsToRemove() As Long
    Dim colCount As Long
    
    ' Find last column with data
    lastCol = ws.Cells(3, ws.Columns.count).End(xlToLeft).Column
    
    ' Initialize collection of columns to remove
    colCount = 0
    ReDim colsToRemove(1 To lastCol) ' Maximum possible columns to remove
    
    ' Identify mapped columns
    For i = 1 To lastCol
        Dim header As String
        header = ws.Cells(3, i).Value
        
        If Len(header) >= 4 Then
            If Right(header, 4) = "_map" Then
                colCount = colCount + 1
                colsToRemove(colCount) = i
            End If
        End If
    Next i
    
    ' Process columns in reverse order to avoid shifting issues
    If colCount > 0 Then
        Application.StatusBar = "Clearing mapped columns..."
        Application.EnableEvents = False
        Application.ScreenUpdating = False
        Application.Calculation = xlCalculationManual
        
        ' Sort columns in descending order to avoid shifting issues
        If colCount > 1 Then
            Dim temp As Long
            Dim i2 As Long, j As Long
            For i2 = 1 To colCount - 1
                For j = i2 + 1 To colCount
                    If colsToRemove(i2) < colsToRemove(j) Then
                        temp = colsToRemove(i2)
                        colsToRemove(i2) = colsToRemove(j)
                        colsToRemove(j) = temp
                    End If
                Next j
            Next i2
        End If
        
        ' Clear columns in reverse order
        For i = 1 To colCount
            Dim colIndex As Long
            colIndex = colsToRemove(i)
            
            ' Clear the column
            ws.Columns(colIndex).ClearContents
            ws.Columns(colIndex).ClearFormats
            
            ' Optionally delete the column instead of just clearing it
            ' ws.Columns(colIndex).Delete Shift:=xlToLeft
        Next i
        
        Application.StatusBar = False
        Application.ScreenUpdating = True
        Application.Calculation = xlCalculationAutomatic
        Application.EnableEvents = True
    End If
    
    Exit Sub
    
ErrorHandler:
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in ClearMappedColumns", vbCritical, "Error"
End Sub

Sub CreateMappingTable()
    ' Create the reconciliation column mapping table in columns I and J of the Input Parameters worksheet
    Dim wsMapping As Worksheet
    Dim wsFileA As Worksheet
    Dim lastColA As Long
    Dim i As Long
    Dim rowNum As Long
    Dim isMappingTableEmpty As Boolean
    
    ' Set worksheets
    Set wsMapping = Worksheets("Input Parameters")
    Set wsFileA = Worksheets("Input File A")
    
    ' Check if the mapping table is already populated
    isMappingTableEmpty = True
    For i = 6 To 25  ' Check rows 6-25
        If wsMapping.Range("I" & i).Value <> "" Then
            isMappingTableEmpty = False
            Exit For
        End If
    Next i
    
    ' Only populate the table if it's empty
    If isMappingTableEmpty Then
        ' Find the last column with data in row 3 (header row)
        lastColA = wsFileA.Cells(3, wsFileA.Columns.count).End(xlToLeft).Column
        
        ' Start adding column mappings from row 6
        rowNum = 6
        
        ' Add File A columns
        For i = 1 To lastColA
            wsMapping.Cells(rowNum, 9).Value = wsFileA.Cells(3, i).Value  ' Column I is index 9
            rowNum = rowNum + 1
            ' Don't exceed the prepared rows (6-25)
            If rowNum > 25 Then Exit For
        Next i
    End If
    
    ' Format the range with borders
    wsMapping.Range("I5:J25").Borders.LineStyle = xlContinuous
    
    ' Auto-fit columns
    wsMapping.Columns("I:J").AutoFit
End Sub

' =================================== MAPPING FUNCTIONS ===================================

Sub ApplyMapping()
    ' Apply mapping defined in the Mapping sheet
    On Error GoTo ErrorHandler
    
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    Dim wsMappingDef As Worksheet
    Dim wsMapping As Worksheet
    Dim rangeToSearch As Range
    Dim cell As Range
    Dim i As Long, j As Long
    Dim lastRow As Long, lastCol As Long
    Dim tableStartRows() As Long
    Dim tableStartCols() As Long  ' Store the column where each table starts
    Dim tableCount As Long
    Dim fileType As String
    Dim columnName As String
    Dim sourceValue As String
    Dim mappedValue As String
    Dim wsInput As Worksheet
    
    ' Set worksheets
    On Error Resume Next
    Set wsMappingDef = Worksheets("Mapping")
    Set wsMapping = Worksheets("Input Parameters")
    On Error GoTo ErrorHandler
    
    If wsMappingDef Is Nothing Then
        MsgBox "Worksheet 'Mapping' not found.", vbExclamation, "Missing Worksheet"
        GoTo CleanExit
    End If
    
    If wsMapping Is Nothing Then
        MsgBox "Worksheet 'Input Parameters' not found.", vbExclamation, "Missing Worksheet"
        GoTo CleanExit
    End If
    
    ' Check if the column mapping table has been filled out
    Dim hasMappings As Boolean
    
    hasMappings = False
    
    ' Check for at least one mapping pair
    For i = 6 To 25  ' Check rows 6-25 (mapping table rows)
        If wsMapping.Cells(i, 9).Value <> "" And wsMapping.Cells(i, 10).Value <> "" Then
            hasMappings = True
            Exit For
        End If
    Next i
    
    If Not hasMappings Then
        MsgBox "The column mapping table is not filled out. Please go to the Input Parameters tab " & _
               "and map columns from Input File A to Input File B in columns I and J.", _
               vbExclamation, "Missing Mappings"
        GoTo CleanExit
    End If
    
    ' Find all mapping tables in the Mapping sheet
    tableCount = 0
    ReDim tableStartRows(1 To 100) ' Assume max 100 mapping tables
    ReDim tableStartCols(1 To 100) ' Store start column for each table
    
    ' Search for "Input File: " text to find mapping table starts
    Set rangeToSearch = wsMappingDef.UsedRange
    
    For Each cell In rangeToSearch.Cells
        If InStr(1, cell.Value, "Input File:", vbTextCompare) > 0 Then
            tableCount = tableCount + 1
            tableStartRows(tableCount) = cell.Row
            tableStartCols(tableCount) = cell.Column ' Store the column
        End If
    Next cell
    
    ' If no mapping tables found, exit
    If tableCount = 0 Then
        MsgBox "No mapping tables found in the Mapping sheet. Skipping this step.", vbInformation, "No Mapping"
        GoTo CleanExit
    End If
    
    ' Process each mapping table
    For i = 1 To tableCount
        ' Get file type (A or B) using safer method
        Dim headerText As String
        Dim startCol As Long
        
        startCol = tableStartCols(i) ' Use the stored column
        headerText = Trim(wsMappingDef.Cells(tableStartRows(i), startCol).Value)
        
        fileType = ""
        If InStr(1, headerText, "Input File: A", vbTextCompare) > 0 Or _
           InStr(1, headerText, "Input File:A", vbTextCompare) > 0 Then
            fileType = "A"
        ElseIf InStr(1, headerText, "Input File: B", vbTextCompare) > 0 Or _
               InStr(1, headerText, "Input File:B", vbTextCompare) > 0 Then
            fileType = "B"
        End If
        
        ' Validation
        If fileType = "" Then
            MsgBox "Invalid file type in mapping table at row " & tableStartRows(i) & ", column " & startCol & vbCrLf & _
                   "Cell contains: """ & headerText & """" & vbCrLf & _
                   "Please use exactly 'Input File: A' or 'Input File: B'", _
                   vbExclamation, "Mapping Error"
            GoTo CleanExit
        End If
        
        ' UPDATED FOR NEW FORMAT: Get column name from row +1 instead of +2
        ' Get column name from the header row (one row below file type)
        columnName = wsMappingDef.Cells(tableStartRows(i) + 1, startCol).Value
        
        ' Debugging message
        Debug.Print "Processing mapping table at row " & tableStartRows(i) & ", column " & startCol & _
                    ", File Type: " & fileType & ", Column Name: " & columnName
        
        ' Column name validation
        If columnName = "" Then
            MsgBox "Missing column name in mapping table at row " & (tableStartRows(i) + 1) & ", column " & startCol & vbCrLf & _
                   "Please specify which column to map in the row below the file type.", _
                   vbExclamation, "Mapping Error"
            GoTo CleanExit
        End If
        
        ' Set the input worksheet based on file type
        If fileType = "A" Then
            Set wsInput = Worksheets("Input File A")
        ElseIf fileType = "B" Then
            Set wsInput = Worksheets("Input File B")
        End If
        
        If wsInput Is Nothing Then
            MsgBox "Worksheet 'Input File " & fileType & "' not found.", vbExclamation, "Missing Worksheet"
            GoTo CleanExit
        End If
        
        ' Find the column with the specified name in the input worksheet
        lastCol = wsInput.Cells(3, wsInput.Columns.count).End(xlToLeft).Column
        Dim columnFound As Boolean
        columnFound = False
        
        For j = 1 To lastCol
            If wsInput.Cells(3, j).Value = columnName Then
                ' Found the column, create a mapped column
                AddMappedColumn wsInput, j, tableStartRows(i), wsMappingDef, startCol
                columnFound = True
                Exit For
            End If
        Next j
        
        ' Column not found warning
        If Not columnFound Then
            MsgBox "Column '" & columnName & "' not found in " & IIf(fileType = "A", "Input File A", "Input File B") & _
                   ". Please check the column name.", vbExclamation, "Column Not Found"
        End If
    Next i
    
CleanExit:
    ' Always restore Excel settings
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    
    If Err.Number = 0 Then
        MsgBox "Mapping applied successfully!", vbInformation, "Mapping Complete"
    End If
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Error in Apply Mapping"
    Resume CleanExit
End Sub

Sub AddMappedColumn(wsInput As Worksheet, columnIndex As Long, tableStartRow As Long, wsMappingDef As Worksheet, startCol As Long)
    ' Create a new column with mapped values instead of replacing original values
    On Error GoTo ErrorHandler
    
    Dim lastRowInput As Long
    Dim i As Long, j As Long
    Dim sourceValue As String
    Dim mappedValue As String
    Dim mappingFound As Boolean
    Dim lastRowMapping As Long
    Dim columnName As String
    Dim lastCol As Long
    Dim newColIndex As Long
    Dim mappedColName As String
    
    ' Get the original column name
    columnName = wsInput.Cells(3, columnIndex).Value
    
    ' Create the new column name with _map suffix
    mappedColName = columnName & "_map"
    
    ' Find the last column with data
    lastCol = wsInput.Cells(3, wsInput.Columns.count).End(xlToLeft).Column
    
    ' Check if the mapped column already exists
    Dim mappedColExists As Boolean
    mappedColExists = False
    
    For j = 1 To lastCol
        If wsInput.Cells(3, j).Value = mappedColName Then
            newColIndex = j
            mappedColExists = True
            Exit For
        End If
    Next j
    
    ' If mapped column doesn't exist, add it at the end
    If Not mappedColExists Then
        newColIndex = lastCol + 1
        
        ' Add column header with _map suffix
        wsInput.Cells(3, newColIndex).Value = mappedColName
        
        ' Format the header with a darker color to distinguish it
        wsInput.Cells(3, newColIndex).Interior.Color = RGB(153, 153, 204) ' Darker shade
        wsInput.Cells(3, newColIndex).Font.Bold = True
    End If
    
    ' Find the last row with data in the input worksheet
    lastRowInput = wsInput.Cells(wsInput.Rows.count, columnIndex).End(xlUp).Row
    
    ' Find the last row of the mapping table - starting from data row after the column name header
    ' UPDATED FOR NEW FORMAT: Start from row +2 instead of +3
    j = tableStartRow + 2 ' First mapping value row (in new format)
    
    Do While j <= wsMappingDef.Rows.count And wsMappingDef.Cells(j, startCol).Value <> ""
        j = j + 1
    Loop
    lastRowMapping = j - 1
    
    ' Copy original values to mapped column and apply mapping
    For i = 4 To lastRowInput ' Start from row 4 (skip header in row 3)
        sourceValue = wsInput.Cells(i, columnIndex).Value
        
        ' Skip empty cells
        If sourceValue <> "" Then
            ' Look for the source value in the mapping table
            mappingFound = False
            
            ' UPDATED FOR NEW FORMAT: Start from row +2 instead of +3
            For j = tableStartRow + 2 To lastRowMapping ' Start from first mapping value row
                If wsMappingDef.Cells(j, startCol).Value = sourceValue Then
                    ' Found a mapping
                    mappedValue = wsMappingDef.Cells(j, startCol + 1).Value
                    wsInput.Cells(i, newColIndex).Value = mappedValue
                    mappingFound = True
                    Exit For
                End If
            Next j
            
            ' If no mapping found, mark the cell
            If Not mappingFound Then
                wsInput.Cells(i, newColIndex).Value = "N/A - failed to map. Original Value: " & sourceValue
                wsInput.Cells(i, newColIndex).Interior.Color = RGB(255, 191, 0) ' Amber color
            End If
        Else
            ' For empty cells, leave the mapped column empty
            wsInput.Cells(i, newColIndex).Value = ""
        End If
    Next i
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & vbCrLf & _
           "While mapping column " & columnIndex & " in " & wsInput.Name, vbCritical, "Error in Apply Mapping"
End Sub



' =================================== RECONCILIATION FUNCTIONS ===================================

Sub RunReconciliation()
    ' Run the reconciliation process
    On Error GoTo ErrorHandler
    
    ' Use optimized application settings
    OptimizeAppSettings True

    ' Declare all variables
    Dim ws As Worksheet
    Dim i As Long
    Dim hasMappings As Boolean
    Dim mappings() As String

    ' Read parameters
    ReadParameters

    ' Check if primary keys are specified
    If gstrPrimaryKeyA = "" Or gstrPrimaryKeyB = "" Then
        MsgBox "Primary keys for reconciliation are not specified. Please provide them in the Input Parameters sheet.", _
               vbExclamation, "Missing Keys"
        GoTo CleanExit
    End If

    ' Check if the column mapping table has been filled out
    Set ws = Worksheets("Input Parameters")
    hasMappings = False

    ' Find the last row with data in column I
    Dim lastMappingRow As Long
    lastMappingRow = ws.Cells(ws.Rows.count, 9).End(xlUp).Row

    ' Ensure we don't go below row 6 (headers are in row 5)
    If lastMappingRow < 6 Then lastMappingRow = 6

    ' Set a reasonable upper limit for performance (change this as needed)
    Const MAX_MAPPING_ROWS As Long = 100
    If lastMappingRow > MAX_MAPPING_ROWS Then lastMappingRow = MAX_MAPPING_ROWS

    ' Check for at least one mapping pair
    hasMappings = False
    For i = 6 To lastMappingRow
        If ws.Cells(i, 9).Value <> "" And ws.Cells(i, 10).Value <> "" Then
            hasMappings = True
            Exit For
        End If
    Next i

    If Not hasMappings Then
        MsgBox "The column mapping table is not filled out. Please go to the Input Parameters tab " & _
               "and map columns from Input File A to Input File B in columns I and J.", _
               vbExclamation, "Missing Mappings"
        GoTo CleanExit
    End If

    ' Get column mappings from Input Parameters sheet
    mappings = GetColumnMappings()

    ' Check if we got any mappings (array size)
    If UBound(mappings, 1) <= 0 And UBound(mappings, 2) <= 0 Then
        GoTo CleanExit  ' GetColumnMappings already showed an error message
    End If

    ' Update status bar
    Application.StatusBar = "Starting reconciliation process..."
    
    ' Perform reconciliation with the mappings
    PerformReconciliation mappings

CleanExit:
    ' Restore application settings
    OptimizeAppSettings False

    If Err.Number = 0 Then
        MsgBox "Reconciliation completed successfully!", vbInformation, "Reconciliation Complete"
    End If

    Exit Sub
ErrorHandler:
    ' Restore application settings
    OptimizeAppSettings False
    
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbCritical, "Error in Reconciliation"
    Resume CleanExit
End Sub

'This function clears Result tab before populating it with new reconciliation results.
Sub ClearResultSheet()
    ' Clear both content and formatting from the Result sheet
    On Error GoTo ErrorHandler
    
    Dim wsResult As Worksheet
    
    ' Set worksheet
    Set wsResult = Worksheets("Result")
    
    ' Preserve title and subtitle
    Dim title As String, subtitle As String
    title = wsResult.Range("A1").Value
    subtitle = wsResult.Range("A2").Value
    
    ' Clear everything from row 3 down (both content and formatting)
    wsResult.Range("A3:ZZ" & wsResult.Rows.count).ClearContents
    wsResult.Range("A3:ZZ" & wsResult.Rows.count).ClearFormats
    
    ' Restore title and subtitle
    wsResult.Range("A1").Value = title
    wsResult.Range("A2").Value = subtitle
    wsResult.Range("A1").Font.Bold = True
    wsResult.Range("A1").Font.Size = 16
    wsResult.Range("A2").Font.Italic = True
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in ClearResultSheet", vbCritical, "Error"
End Sub

' This function gets the mappings as two parallel arrays in a single 2D array
Function GetColumnMappings() As String()
    ' Get column mappings from Input Parameters sheet with increased capacity
    On Error GoTo ErrorHandler
    
    Dim ws As Worksheet
    Dim i As Long, count As Long
    Dim mappings() As String
    Dim lastMappingRow As Long
    
    ' Set worksheet
    Set ws = Worksheets("Input Parameters")
    
    ' Find the last row with data in column I (allowing for more mappings)
    ' This replaces the hardcoded limit of row 25
    lastMappingRow = ws.Cells(ws.Rows.count, 9).End(xlUp).Row
    
    ' Ensure we don't go below row 6 (headers are in row 5)
    If lastMappingRow < 6 Then lastMappingRow = 6
    
    ' Set a reasonable upper limit for performance (change this as needed)
    Const MAX_MAPPING_ROWS As Long = 100
    If lastMappingRow > MAX_MAPPING_ROWS Then lastMappingRow = MAX_MAPPING_ROWS
    
    ' First count how many mappings we have
    count = 0
    For i = 6 To lastMappingRow
        If ws.Cells(i, 9).Value <> "" And ws.Cells(i, 10).Value <> "" Then
            count = count + 1
        End If
    Next i
    
    If count = 0 Then
        MsgBox "The column mapping table is not filled out. Please go to the Input Parameters tab " & _
               "and map columns from Input File A to Input File B in columns I and J.", _
               vbExclamation, "Missing Mappings"
        ReDim mappings(0 To 0, 0 To 1)  ' Return empty array with proper dimensions
        GetColumnMappings = mappings
        Exit Function
    End If
    
    ' Create a 2D array to hold mappings - first column for A, second for B
    ReDim mappings(0 To count - 1, 0 To 1)
    
    ' Read mappings into the 2D array
    count = 0
    For i = 6 To lastMappingRow
        If ws.Cells(i, 9).Value <> "" And ws.Cells(i, 10).Value <> "" Then
            mappings(count, 0) = ws.Cells(i, 9).Value
            mappings(count, 1) = ws.Cells(i, 10).Value
            count = count + 1
        End If
    Next i
    
    GetColumnMappings = mappings
    Exit Function
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in GetColumnMappings", vbCritical, "Error"
    ReDim mappings(0 To 0, 0 To 1)  ' Return empty array with proper dimensions
    GetColumnMappings = mappings
End Function

' The main reconciliation function
' First, add these helper functions to your module (outside of any other functions):

Function GenerateConsistentKey(primaryKey As String, secondaryKey As String, useCompositeKey As Boolean) As String
    ' Create a standardized key format to ensure consistency
    If useCompositeKey And secondaryKey <> "" Then
        GenerateConsistentKey = primaryKey & "|" & secondaryKey
    Else
        GenerateConsistentKey = primaryKey
    End If
End Function

Function KeyExistsInLookup(keys() As String, count As Long, key As String, caseSensitive As Boolean) As Long
    Dim i As Long
    KeyExistsInLookup = 0 ' Default to not found
    
    For i = 1 To count
        If (caseSensitive And StrComp(keys(i), key, vbBinaryCompare) = 0) Or _
           (Not caseSensitive And StrComp(keys(i), key, vbTextCompare) = 0) Then
            KeyExistsInLookup = i ' Return the index
            Exit Function
        End If
    Next i
End Function

Sub BuildLookupIndex(ws As Worksheet, primaryKeyCol As Long, secondaryKeyCol As Long, _
                     startRow As Long, endRow As Long, _
                     ByRef keys() As String, ByRef values() As Long, ByRef count As Long, _
                     useArrays As Boolean, dataArray() As Variant, useCompositeKey As Boolean)
    ' Clear the previous data
    count = 0
    
    ' Process records in chunks for better performance
    Const CHUNK_SIZE As Long = 1000
    Dim chunk As Long, i As Long
    
    For chunk = 0 To ((endRow - startRow) \ CHUNK_SIZE)
        Dim chunkStart As Long, chunkEnd As Long
        chunkStart = startRow + chunk * CHUNK_SIZE
        chunkEnd = Application.Min(chunkStart + CHUNK_SIZE - 1, endRow)
        
        ' Update status
        Application.StatusBar = "Building lookup index: " & Format(((chunk + 1) * CHUNK_SIZE) / (endRow - startRow + 1), "0%")
        
        For i = chunkStart To chunkEnd
            Dim primaryKey As String, secondaryKey As String
            
            ' Get key values efficiently
            If useArrays Then
                primaryKey = dataArray(i, primaryKeyCol)
                If useCompositeKey And secondaryKeyCol > 0 Then
                    secondaryKey = dataArray(i, secondaryKeyCol)
                Else
                    secondaryKey = ""
                End If
            Else
                primaryKey = Trim(ws.Cells(i, primaryKeyCol).Value)
                If useCompositeKey And secondaryKeyCol > 0 Then
                    secondaryKey = Trim(ws.Cells(i, secondaryKeyCol).Value)
                Else
                    secondaryKey = ""
                End If
            End If
            
            ' Create lookup key
            Dim lookupKey As String
            lookupKey = GenerateConsistentKey(primaryKey, secondaryKey, useCompositeKey)
            
            ' Add to index - no need to check for duplicates as we're using the first occurrence
            ' This gives better performance and handles the case of duplicates properly
            count = count + 1
            
            ' Check if we need to resize arrays
            If count > UBound(keys) Then
                ReDim Preserve keys(1 To count * 2)
                ReDim Preserve values(1 To count * 2)
            End If
            
            keys(count) = lookupKey
            values(count) = i ' Store row index
        Next i
    Next chunk
End Sub

' Now, here's the complete optimized PerformReconciliation function:

Sub PerformReconciliation(mappings() As String)
    ' Perform the reconciliation and populate the Result sheet using a 2D array of mappings
    ' Optimized version with case-sensitive comparison and cross-platform compatibility
    On Error GoTo ErrorHandler

    ' Variable declarations
    Dim wsFileA As Worksheet
    Dim wsFileB As Worksheet
    Dim wsResult As Worksheet
    Dim wsSupplA As Worksheet
    Dim wsSupplB As Worksheet
    Dim lastRowA As Long, lastRowB As Long
    Dim lastColA As Long, lastColB As Long
    Dim lastColSupplA As Long, lastColSupplB As Long
    Dim i As Long, j As Long, k As Long
    Dim rowResult As Long
    Dim colPrimaryKeyA As Long, colPrimaryKeyB As Long
    Dim colSecondaryKeyA As Long, colSecondaryKeyB As Long
    Dim colSupplKeyA As Long, colSupplKeyB As Long
    Dim primaryKeyValueA As String, primaryKeyValueB As String
    Dim secondaryKeyValueA As String, secondaryKeyValueB As String
    Dim matchFound As Boolean
    Dim matchType As String
    Dim matchRowB As Long
    Dim colA As Long, colB As Long
    Dim valueA As String, valueB As String
    Dim dataA() As Variant
    Dim dataB() As Variant
    Dim supplDataA() As Variant
    Dim supplDataB() As Variant
    Dim headerA() As String
    Dim headerB() As String
    Dim headerSupplA() As String
    Dim headerSupplB() As String
    Dim requiredSupplColsA() As String
    Dim requiredSupplColsB() As String
    Dim requiredSupplColIndexA() As Long
    Dim requiredSupplColIndexB() As Long
    Dim hasSupplA As Boolean
    Dim hasSupplB As Boolean
    Dim lastRowSupplA As Long
    Dim lastRowSupplB As Long
    Dim supplMatchRowA As Long
    Dim supplMatchRowB As Long
    Dim singletonSupplMatchRowB As Long
    Dim reconColCount As Long
    Dim colOffset As Long
    Dim columnFound As Boolean
    Dim mappingCount As Long
    Dim lookupKey As String
    Dim resultsArray() As Variant
    Dim totalCols As Long
    Dim actualRows As Long
    Dim isMac As Boolean
    Dim chunk As Long
    Dim startRow As Long, endRow As Long
    
    ' Case-sensitive comparison flag
    Dim useCaseSensitive As Boolean
    useCaseSensitive = True ' Set to True for case-sensitive comparison

    ' Variables for tracking mismatched fields
    Dim mismatchedFields As String
    Dim hasMismatch As Boolean

    ' Variables for mapped columns
    Dim colAComp As Long, colBComp As Long
    Dim mappedColNameA As String, mappedColNameB As String
    Dim hasMappedCol As Boolean
    Dim mappedColIndex As Long
    
    ' Optimized lookup arrays
    Dim colMapAKeys() As String
    Dim colMapAValues() As Long
    Dim colMapACount As Long
    
    Dim colMapBKeys() As String
    Dim colMapBValues() As Long
    Dim colMapBCount As Long
    
    ' File B lookup arrays (both primary and composite keys)
    Dim fileBPrimaryKeys() As String
    Dim fileBPrimaryValues() As Long
    Dim fileBPrimaryCount As Long
    
    Dim fileBCompositeKeys() As String
    Dim fileBCompositeValues() As Long
    Dim fileBCompositeCount As Long
    
    ' File A lookup arrays (for singleton B detection)
    Dim fileAPrimaryKeys() As String
    Dim fileAPrimaryValues() As Long
    Dim fileAPrimaryCount As Long
    
    Dim fileACompositeKeys() As String
    Dim fileACompositeValues() As Long
    Dim fileACompositeCount As Long
    
    ' Initialize the arrays
    ReDim colMapAKeys(1 To 1000)
    ReDim colMapAValues(1 To 1000)
    colMapACount = 0
    
    ReDim colMapBKeys(1 To 1000)
    ReDim colMapBValues(1 To 1000)
    colMapBCount = 0
    
    ReDim fileBPrimaryKeys(1 To 5000)
    ReDim fileBPrimaryValues(1 To 5000)
    fileBPrimaryCount = 0
    
    ReDim fileBCompositeKeys(1 To 5000)
    ReDim fileBCompositeValues(1 To 5000)
    fileBCompositeCount = 0
    
    ReDim fileAPrimaryKeys(1 To 5000)
    ReDim fileAPrimaryValues(1 To 5000)
    fileAPrimaryCount = 0
    
    ReDim fileACompositeKeys(1 To 5000)
    ReDim fileACompositeValues(1 To 5000)
    fileACompositeCount = 0
    
    ' Check platform
    #If Mac Then
        isMac = True
    #Else
        isMac = False
    #End If

    ' Safely get mapping count
    On Error Resume Next
    mappingCount = UBound(mappings, 1) + 1
    If Err.Number <> 0 Then
        mappingCount = 0
    End If
    On Error GoTo ErrorHandler

    ' Set worksheets with error handling
    On Error Resume Next
    Set wsFileA = Worksheets("Input File A")
    Set wsFileB = Worksheets("Input File B")
    Set wsResult = Worksheets("Result")
    Set wsSupplA = Worksheets("Supplementary File A")
    Set wsSupplB = Worksheets("Supplementary File B")

    If wsFileA Is Nothing Then
        MsgBox "Worksheet 'Input File A' not found.", vbExclamation, "Missing Worksheet"
        Exit Sub
    End If

    If wsFileB Is Nothing Then
        MsgBox "Worksheet 'Input File B' not found.", vbExclamation, "Missing Worksheet"
        Exit Sub
    End If

    If wsResult Is Nothing Then
        MsgBox "Worksheet 'Result' not found.", vbExclamation, "Missing Worksheet"
        Exit Sub
    End If

    On Error GoTo ErrorHandler

    ' Clear Result sheet (both content and formatting)
    ClearResultSheet

    ' Find the last rows and columns with data
    lastRowA = wsFileA.Cells(wsFileA.Rows.count, 1).End(xlUp).Row
    lastRowB = wsFileB.Cells(wsFileB.Rows.count, 1).End(xlUp).Row
    lastColA = wsFileA.Cells(3, wsFileA.Columns.count).End(xlToLeft).Column
    lastColB = wsFileB.Cells(3, wsFileB.Columns.count).End(xlToLeft).Column

    ' Check if data exists
    If lastRowA <= 3 Then
        MsgBox "No data found in Input File A.", vbExclamation, "No Data"
        Exit Sub
    End If

    If lastRowB <= 3 Then
        MsgBox "No data found in Input File B.", vbExclamation, "No Data"
        Exit Sub
    End If

    ' Update status
    Application.StatusBar = "Preparing column indexes..."

    ' Build column maps for faster lookups
    ' Column map for file A
    For i = 1 To lastColA
        colMapACount = colMapACount + 1
        If colMapACount > UBound(colMapAKeys) Then
            ReDim Preserve colMapAKeys(1 To colMapACount * 2)
            ReDim Preserve colMapAValues(1 To colMapACount * 2)
        End If
        
        colMapAKeys(colMapACount) = wsFileA.Cells(3, i).Value
        colMapAValues(colMapACount) = i
        
        ' Also map _map columns
        If Right(wsFileA.Cells(3, i).Value, 4) <> "_map" Then
            Dim mappedColA As String
            mappedColA = wsFileA.Cells(3, i).Value & "_map"
            
            ' Try to find the mapped column
            For j = 1 To lastColA
                If wsFileA.Cells(3, j).Value = mappedColA Then
                    colMapACount = colMapACount + 1
                    If colMapACount > UBound(colMapAKeys) Then
                        ReDim Preserve colMapAKeys(1 To colMapACount * 2)
                        ReDim Preserve colMapAValues(1 To colMapACount * 2)
                    End If
                    colMapAKeys(colMapACount) = mappedColA
                    colMapAValues(colMapACount) = j
                    Exit For
                End If
            Next j
        End If
    Next i
    
    ' Column map for file B
    For i = 1 To lastColB
        colMapBCount = colMapBCount + 1
        If colMapBCount > UBound(colMapBKeys) Then
            ReDim Preserve colMapBKeys(1 To colMapBCount * 2)
            ReDim Preserve colMapBValues(1 To colMapBCount * 2)
        End If
        
        colMapBKeys(colMapBCount) = wsFileB.Cells(3, i).Value
        colMapBValues(colMapBCount) = i
        
        ' Also map _map columns
        If Right(wsFileB.Cells(3, i).Value, 4) <> "_map" Then
            Dim mappedColB As String
            mappedColB = wsFileB.Cells(3, i).Value & "_map"
            
            ' Try to find the mapped column
            For j = 1 To lastColB
                If wsFileB.Cells(3, j).Value = mappedColB Then
                    colMapBCount = colMapBCount + 1
                    If colMapBCount > UBound(colMapBKeys) Then
                        ReDim Preserve colMapBKeys(1 To colMapBCount * 2)
                        ReDim Preserve colMapBValues(1 To colMapBCount * 2)
                    End If
                    colMapBKeys(colMapBCount) = mappedColB
                    colMapBValues(colMapBCount) = j
                    Exit For
                End If
            Next j
        End If
    Next i

    ' Find the primary and secondary key columns using our column maps
    colPrimaryKeyA = 0
    colPrimaryKeyB = 0
    colSecondaryKeyA = 0
    colSecondaryKeyB = 0
    
    For i = 1 To colMapACount
        If colMapAKeys(i) = gstrPrimaryKeyA Then
            colPrimaryKeyA = colMapAValues(i)
        ElseIf gstrSecondaryKeyA <> "" And colMapAKeys(i) = gstrSecondaryKeyA Then
            colSecondaryKeyA = colMapAValues(i)
        End If
    Next i
    
    For i = 1 To colMapBCount
        If colMapBKeys(i) = gstrPrimaryKeyB Then
            colPrimaryKeyB = colMapBValues(i)
        ElseIf gstrSecondaryKeyB <> "" And colMapBKeys(i) = gstrSecondaryKeyB Then
            colSecondaryKeyB = colMapBValues(i)
        End If
    Next i
    
    If colPrimaryKeyA = 0 Then
        MsgBox "Primary key column '" & gstrPrimaryKeyA & "' not found in Input File A.", vbExclamation, "Key Not Found"
        Exit Sub
    End If
    
    If colPrimaryKeyB = 0 Then
        MsgBox "Primary key column '" & gstrPrimaryKeyB & "' not found in Input File B.", vbExclamation, "Key Not Found"
        Exit Sub
    End If

    If gstrSecondaryKeyA <> "" And colSecondaryKeyA = 0 Then
        MsgBox "Secondary key column '" & gstrSecondaryKeyA & "' not found in Input File A.", vbExclamation, "Key Not Found"
        Exit Sub
    End If

    If gstrSecondaryKeyB <> "" And colSecondaryKeyB = 0 Then
        MsgBox "Secondary key column '" & gstrSecondaryKeyB & "' not found in Input File B.", vbExclamation, "Key Not Found"
        Exit Sub
    End If

    ' Check supplementary files
    hasSupplA = False
    hasSupplB = False

    ' Safely check if supplementary files exist
    On Error Resume Next
    hasSupplA = (gstrSupplementaryFileAPath <> "" And Not wsSupplA Is Nothing)
    hasSupplB = (gstrSupplementaryFileBPath <> "" And Not wsSupplB Is Nothing)
    On Error GoTo ErrorHandler

    ' Find supplementary key columns if needed
    If hasSupplA Then
        On Error Resume Next
        lastColSupplA = wsSupplA.Cells(3, wsSupplA.Columns.count).End(xlToLeft).Column
        colSupplKeyA = FindColumnIndex(wsSupplA, gstrSupplementaryASourceKey)
                
        If Err.Number <> 0 Or colSupplKeyA = 0 Then
            If Err.Number = 0 Then
                MsgBox "Supplementary key column '" & gstrSupplementaryASourceKey & "' not found in Supplementary File A.", _
                      vbExclamation, "Key Not Found"
            Else
                MsgBox "Error accessing Supplementary File A: " & Err.Description, vbExclamation, "Error"
            End If
            hasSupplA = False
        End If
                
        ' Get required supplementary columns for File A
        On Error Resume Next
        requiredSupplColsA = GetRequiredSupplementaryColumns("A")
        If Err.Number <> 0 Then
            MsgBox "Error getting supplementary columns for File A: " & Err.Description, vbExclamation, "Error"
            ReDim requiredSupplColsA(0)
            requiredSupplColsA(0) = ""
        End If
                
        On Error GoTo ErrorHandler
                
        ' Check if requiredSupplColsA is properly initialized
        Dim suppColsAFound As Boolean
        suppColsAFound = False
                
        On Error Resume Next
        If UBound(requiredSupplColsA) >= 0 Then
            suppColsAFound = True
        End If
        On Error GoTo ErrorHandler
                
        If hasSupplA And suppColsAFound Then
            On Error Resume Next
            ReDim requiredSupplColIndexA(UBound(requiredSupplColsA))
                        
            For i = 0 To UBound(requiredSupplColsA)
                requiredSupplColIndexA(i) = FindColumnIndex(wsSupplA, requiredSupplColsA(i))
                                
                If requiredSupplColIndexA(i) = 0 Then
                    ' Skip reporting error for empty column names
                    If requiredSupplColsA(i) <> "" Then
                        MsgBox "Required supplementary column '" & requiredSupplColsA(i) & "' not found in Supplementary File A.", _
                               vbExclamation, "Column Not Found"
                    End If
                End If
            Next i
            On Error GoTo ErrorHandler
        End If
    End If
        
    If hasSupplB Then
        On Error Resume Next
        lastColSupplB = wsSupplB.Cells(3, wsSupplB.Columns.count).End(xlToLeft).Column
        colSupplKeyB = FindColumnIndex(wsSupplB, gstrSupplementaryBSourceKey)
                
        If Err.Number <> 0 Or colSupplKeyB = 0 Then
            If Err.Number = 0 Then
                MsgBox "Supplementary key column '" & gstrSupplementaryBSourceKey & "' not found in Supplementary File B.", _
                      vbExclamation, "Key Not Found"
            Else
                MsgBox "Error accessing Supplementary File B: " & Err.Description, vbExclamation, "Error"
            End If
            hasSupplB = False
        End If
                
        ' Get required supplementary columns for File B
        On Error Resume Next
        requiredSupplColsB = GetRequiredSupplementaryColumns("B")
        If Err.Number <> 0 Then
            MsgBox "Error getting supplementary columns for File B: " & Err.Description, vbExclamation, "Error"
            ReDim requiredSupplColsB(0)
            requiredSupplColsB(0) = ""
        End If
                
        On Error GoTo ErrorHandler
                
        ' Check if requiredSupplColsB is properly initialized
        Dim suppColsBFound As Boolean
        suppColsBFound = False
                
        On Error Resume Next
        If UBound(requiredSupplColsB) >= 0 Then
            suppColsBFound = True
        End If
        On Error GoTo ErrorHandler
                
        If hasSupplB And suppColsBFound Then
            On Error Resume Next
            ReDim requiredSupplColIndexB(UBound(requiredSupplColsB))
                        
            For i = 0 To UBound(requiredSupplColsB)
                requiredSupplColIndexB(i) = FindColumnIndex(wsSupplB, requiredSupplColsB(i))
                                
                If requiredSupplColIndexB(i) = 0 Then
                    ' Skip reporting error for empty column names
                    If requiredSupplColsB(i) <> "" Then
                        MsgBox "Required supplementary column '" & requiredSupplColsB(i) & "' not found in Supplementary File B.", _
                               vbExclamation, "Column Not Found"
                    End If
                End If
            Next i
            On Error GoTo ErrorHandler
        End If
    End If

    ' OPTIMIZATION: Load data into arrays for faster processing
    ' Define maximum array sizes based on platform
    Dim maxArraySize As Long
    
    ' Check if Mac (adjust array sizes for Mac's more limited memory)
    If isMac Then
        maxArraySize = 300000 ' More conservative limit for Mac
    Else
        maxArraySize = 5000000 ' Higher limit for Windows
    End If
    
    ' Check if data will fit in arrays
    Dim useArrays As Boolean
    useArrays = ((lastRowA - 3) * lastColA < maxArraySize) And ((lastRowB - 3) * lastColB < maxArraySize)
    
    ' Update status
    Application.StatusBar = "Loading data into memory..."
    
    If useArrays Then
        ' Load all data at once into arrays
        On Error Resume Next
        ReDim dataA(4 To lastRowA, 1 To lastColA)
        ReDim dataB(4 To lastRowB, 1 To lastColB)
        
        ' Read in chunks to avoid memory issues
        Const CHUNK_SIZE As Long = 1000
        
        For chunk = 0 To (lastRowA - 4) \ CHUNK_SIZE
            startRow = 4 + chunk * CHUNK_SIZE
            endRow = Application.Min(startRow + CHUNK_SIZE - 1, lastRowA)
            
            For i = startRow To endRow
                For j = 1 To lastColA
                    dataA(i, j) = Trim(wsFileA.Cells(i, j).Value)
                Next j
            Next i
            
            ' Update status every chunk
            Application.StatusBar = "Loading File A data: " & _
                Format((endRow - 4) / (lastRowA - 4), "0%") & " complete..."
        Next chunk
        
        For chunk = 0 To (lastRowB - 4) \ CHUNK_SIZE
            startRow = 4 + chunk * CHUNK_SIZE
            endRow = Application.Min(startRow + CHUNK_SIZE - 1, lastRowB)
            
            For i = startRow To endRow
                For j = 1 To lastColB
                    dataB(i, j) = Trim(wsFileB.Cells(i, j).Value)
                Next j
            Next i
            
            ' Update status every chunk
            Application.StatusBar = "Loading File B data: " & _
                Format((endRow - 4) / (lastRowB - 4), "0%") & " complete..."
        Next chunk
        
        If Err.Number <> 0 Then
            useArrays = False
            Err.Clear
        End If
        On Error GoTo ErrorHandler
    End If
    
    ' Load supplementary data if needed
    If hasSupplA Then
        On Error Resume Next
        lastRowSupplA = wsSupplA.Cells(wsSupplA.Rows.count, 1).End(xlUp).Row
                
        If lastRowSupplA > 3 Then
            ReDim supplDataA(4 To lastRowSupplA, 1 To lastColSupplA)
                        
            For i = 4 To lastRowSupplA
                For j = 1 To lastColSupplA
                    supplDataA(i, j) = Trim(wsSupplA.Cells(i, j).Value)
                Next j
            Next i
        Else
            hasSupplA = False
        End If
        On Error GoTo ErrorHandler
    End If
        
    If hasSupplB Then
        On Error Resume Next
        lastRowSupplB = wsSupplB.Cells(wsSupplB.Rows.count, 1).End(xlUp).Row
                
        If lastRowSupplB > 3 Then
            ReDim supplDataB(4 To lastRowSupplB, 1 To lastColSupplB)
                        
            For i = 4 To lastRowSupplB
                For j = 1 To lastColSupplB
                    supplDataB(i, j) = Trim(wsSupplB.Cells(i, j).Value)
                Next j
            Next i
        Else
            hasSupplB = False
        End If
        On Error GoTo ErrorHandler
    End If
    
    ' Get headers from both files
    ReDim headerA(1 To lastColA)
    ReDim headerB(1 To lastColB)
        
    For i = 1 To lastColA
        headerA(i) = wsFileA.Cells(3, i).Value
    Next i
        
    For i = 1 To lastColB
        headerB(i) = wsFileB.Cells(3, i).Value
    Next i
    
    ' Get headers from supplementary files if needed
    If hasSupplA Then
        On Error Resume Next
        ReDim headerSupplA(1 To lastColSupplA)
                
        For i = 1 To lastColSupplA
            headerSupplA(i) = wsSupplA.Cells(3, i).Value
        Next i
        On Error GoTo ErrorHandler
    End If
        
    If hasSupplB Then
        On Error Resume Next
        ReDim headerSupplB(1 To lastColSupplB)
                
        For i = 1 To lastColSupplB
            headerSupplB(i) = wsSupplB.Cells(3, i).Value
        Next i
        On Error GoTo ErrorHandler
    End If
    
    ' OPTIMIZATION: Build optimized lookup indexes
    Application.StatusBar = "Building optimized lookup tables..."
    
    ' Build primary key lookup for File B
    BuildLookupIndex wsFileB, colPrimaryKeyB, 0, _
                     4, lastRowB, _
                     fileBPrimaryKeys, fileBPrimaryValues, fileBPrimaryCount, _
                     useArrays, dataB, False
    
    ' Build composite key lookup for File B if using secondary keys
    If colSecondaryKeyB > 0 Then
        BuildLookupIndex wsFileB, colPrimaryKeyB, colSecondaryKeyB, _
                         4, lastRowB, _
                         fileBCompositeKeys, fileBCompositeValues, fileBCompositeCount, _
                         useArrays, dataB, True
    End If
    
    ' Build primary key lookup for File A (for singleton B detection)
    BuildLookupIndex wsFileA, colPrimaryKeyA, 0, _
                     4, lastRowA, _
                     fileAPrimaryKeys, fileAPrimaryValues, fileAPrimaryCount, _
                     useArrays, dataA, False
    
    ' Build composite key lookup for File A if using secondary keys
    If colSecondaryKeyA > 0 And colSecondaryKeyB > 0 Then
        BuildLookupIndex wsFileA, colPrimaryKeyA, colSecondaryKeyA, _
                         4, lastRowA, _
                         fileACompositeKeys, fileACompositeValues, fileACompositeCount, _
                         useArrays, dataA, True
    End If
    
    ' Set up Result sheet headers
    Application.StatusBar = "Setting up result columns..."
    
    ' Column 1: Reconciliation Result
    wsResult.Cells(3, 1).Value = "Recon Result"
    wsResult.Columns("A:A").ColumnWidth = 50  ' Increase the width for detailed mismatch info
    
    ' Set up column headers for File A, File B, and reconciliation results
    colOffset = 2 ' Start after Recon Result column

    ' Columns for File A data - include both original and mapped columns
    For i = 1 To lastColA
        ' Check if this is a mapped column (ends with _map)
        If Right(wsFileA.Cells(3, i).Value, 4) <> "_map" Then
            wsResult.Cells(3, colOffset).Value = wsFileA.Cells(3, i).Value & " (" & gstrInputASource & ")"
            wsResult.Cells(3, colOffset).Interior.Color = RGB(204, 204, 255) ' Match Input File A color
            colOffset = colOffset + 1
            
            ' Check if there's a mapped version of this column
            mappedColNameA = wsFileA.Cells(3, i).Value & "_map"
            mappedColIndex = 0
            
            For j = 1 To colMapACount
                If colMapAKeys(j) = mappedColNameA Then
                    mappedColIndex = colMapAValues(j)
                    Exit For
                End If
            Next j
            
            If mappedColIndex > 0 Then
                ' Add the mapped column too
                wsResult.Cells(3, colOffset).Value = mappedColNameA & " (" & gstrInputASource & ")"
                wsResult.Cells(3, colOffset).Interior.Color = RGB(153, 153, 204) ' Darker shade for mapped columns
                wsResult.Cells(3, colOffset).Font.Bold = True
                colOffset = colOffset + 1
            End If
        End If
    Next i

    ' Columns for Supplementary File A data if needed
    Dim suppColsAInitialized As Boolean
    suppColsAInitialized = False

    On Error Resume Next
    If hasSupplA And UBound(requiredSupplColsA) >= 0 Then
        suppColsAInitialized = True
    End If
    On Error GoTo ErrorHandler

    If hasSupplA And suppColsAInitialized Then
        For i = 0 To UBound(requiredSupplColsA)
            If requiredSupplColsA(i) <> "" Then
                wsResult.Cells(3, colOffset).Value = requiredSupplColsA(i) & " (Suppl " & gstrInputASource & ")"
                wsResult.Cells(3, colOffset).Interior.Color = RGB(204, 255, 255) ' Match Supplementary File A color
                colOffset = colOffset + 1
            End If
        Next i
    End If

    ' Columns for File B data - include both original and mapped columns
    For i = 1 To lastColB
        ' Check if this is a mapped column (ends with _map)
        If Right(wsFileB.Cells(3, i).Value, 4) <> "_map" Then
            wsResult.Cells(3, colOffset).Value = wsFileB.Cells(3, i).Value & " (" & gstrInputBSource & ")"
            wsResult.Cells(3, colOffset).Interior.Color = RGB(255, 153, 153) ' Match Input File B color
            colOffset = colOffset + 1
            
            ' Check if there's a mapped version of this column
            mappedColNameB = wsFileB.Cells(3, i).Value & "_map"
            mappedColIndex = 0
            
            For j = 1 To colMapBCount
                If colMapBKeys(j) = mappedColNameB Then
                    mappedColIndex = colMapBValues(j)
                    Exit For
                End If
            Next j
            
            If mappedColIndex > 0 Then
                ' Add the mapped column too
                wsResult.Cells(3, colOffset).Value = mappedColNameB & " (" & gstrInputBSource & ")"
                wsResult.Cells(3, colOffset).Interior.Color = RGB(153, 153, 204) ' Darker shade for mapped columns
                wsResult.Cells(3, colOffset).Font.Bold = True
                colOffset = colOffset + 1
            End If
        End If
    Next i

    ' Columns for Supplementary File B data if needed
    Dim suppColsBInitialized As Boolean
    suppColsBInitialized = False

    On Error Resume Next
    If hasSupplB And UBound(requiredSupplColsB) >= 0 Then
        suppColsBInitialized = True
    End If
    On Error GoTo ErrorHandler

    If hasSupplB And suppColsBInitialized Then
        For i = 0 To UBound(requiredSupplColsB)
            If requiredSupplColsB(i) <> "" Then
                wsResult.Cells(3, colOffset).Value = requiredSupplColsB(i) & " (Suppl " & gstrInputBSource & ")"
                wsResult.Cells(3, colOffset).Interior.Color = RGB(255, 204, 255) ' Match Supplementary File B color
                colOffset = colOffset + 1
            End If
        Next i
    End If

    ' Columns for reconciliation results
    reconColCount = 0

    ' Loop through the mappings array
    If mappingCount > 0 Then
        For i = 0 To UBound(mappings, 1)
            colA = 0
            colB = 0
            
            ' Find column indexes using our maps
            For j = 1 To colMapACount
                If colMapAKeys(j) = mappings(i, 0) Then
                    colA = colMapAValues(j)
                    Exit For
                End If
            Next j
            
            For j = 1 To colMapBCount
                If colMapBKeys(j) = mappings(i, 1) Then
                    colB = colMapBValues(j)
                    Exit For
                End If
            Next j
            
            ' If both original columns exist, add a recon column
            If colA > 0 And colB > 0 Then
                wsResult.Cells(3, colOffset).Value = mappings(i, 0) & " vs " & mappings(i, 1) & " (Recon)"
                wsResult.Cells(3, colOffset).Interior.Color = RGB(255, 204, 153) ' Match Result color
                colOffset = colOffset + 1
                reconColCount = reconColCount + 1
            End If
        Next i
    End If
    
    ' Start populating reconciliation results
    Application.StatusBar = "Processing File A records..."
    rowResult = 4 ' Start at row 4 for results
    
    ' Process each record in File A
    For i = 4 To lastRowA
        ' Update status bar periodically
        If i Mod 100 = 0 Then
            Application.StatusBar = "Processing File A record " & i & " of " & lastRowA & _
                                   " (" & Format((i - 4) / (lastRowA - 4), "0%") & ")"
        End If
        
        ' Get key values efficiently
        If useArrays Then
            primaryKeyValueA = dataA(i, colPrimaryKeyA)
            If colSecondaryKeyA > 0 Then
                secondaryKeyValueA = dataA(i, colSecondaryKeyA)
            Else
                secondaryKeyValueA = ""
            End If
        Else
            primaryKeyValueA = Trim(wsFileA.Cells(i, colPrimaryKeyA).Value)
            If colSecondaryKeyA > 0 Then
                secondaryKeyValueA = Trim(wsFileA.Cells(i, colSecondaryKeyA).Value)
            Else
                secondaryKeyValueA = ""
            End If
        End If
        
        ' Match finding with optimized lookups
        matchFound = False
        matchType = ""
        matchRowB = 0
        
        ' Try full match with composite key first (if available)
        If colSecondaryKeyA > 0 And colSecondaryKeyB > 0 Then
            ' Create composite lookup key
            lookupKey = GenerateConsistentKey(primaryKeyValueA, secondaryKeyValueA, True)
            
            ' Look for match in the composite key index
            Dim compositeMatchIndex As Long
            compositeMatchIndex = KeyExistsInLookup(fileBCompositeKeys, fileBCompositeCount, lookupKey, useCaseSensitive)
            
            If compositeMatchIndex > 0 Then
                matchFound = True
                matchType = "Full Match"
                matchRowB = fileBCompositeValues(compositeMatchIndex)
            End If
        End If
        
        ' If no composite match, try primary key only
        If Not matchFound Then
            ' Create primary key lookup
            lookupKey = GenerateConsistentKey(primaryKeyValueA, "", False)
            
            ' Look for match in primary key index
            Dim primaryMatchIndex As Long
            primaryMatchIndex = KeyExistsInLookup(fileBPrimaryKeys, fileBPrimaryCount, lookupKey, useCaseSensitive)
            
            If primaryMatchIndex > 0 Then
                matchFound = True
                matchType = "Primary Key Match"
                matchRowB = fileBPrimaryValues(primaryMatchIndex)
            End If
        End If
        
        ' Process matched or singleton record
        If matchFound Then
            ' Pre-check for mismatches to enhance the result message
            mismatchedFields = ""
            hasMismatch = False
            
            ' Check each mapped column for mismatches - using optimization
            If mappingCount > 0 Then
                ' Pre-fetch all values for comparison at once (reduces cell access)
                Dim compareValuesA() As String
                Dim compareValuesB() As String
                ReDim compareValuesA(0 To UBound(mappings, 1))
                ReDim compareValuesB(0 To UBound(mappings, 1))
                
                ' Collect all values first for batch comparison
                For k = 0 To UBound(mappings, 1)
                    colA = 0
                    colB = 0
                    
                    ' Find column indexes using maps
                    For j = 1 To colMapACount
                        If colMapAKeys(j) = mappings(k, 0) Then
                            colA = colMapAValues(j)
                            Exit For
                        End If
                    Next j
                    
                    For j = 1 To colMapBCount
                        If colMapBKeys(j) = mappings(k, 1) Then
                            colB = colMapBValues(j)
                            Exit For
                        End If
                    Next j
                    
                    If colA > 0 And colB > 0 Then
                        ' Try to find mapped columns for comparison
                        mappedColNameA = mappings(k, 0) & "_map"
                        mappedColNameB = mappings(k, 1) & "_map"
                        
                        colAComp = 0
                        colBComp = 0
                        
                        For j = 1 To colMapACount
                            If colMapAKeys(j) = mappedColNameA Then
                                colAComp = colMapAValues(j)
                                Exit For
                            End If
                        Next j
                        
                        For j = 1 To colMapBCount
                            If colMapBKeys(j) = mappedColNameB Then
                                colBComp = colMapBValues(j)
                                Exit For
                            End If
                        Next j
                        
                        ' Use mapped columns if available, otherwise use original
                        If colAComp > 0 Then
                            If useArrays Then
                                compareValuesA(k) = dataA(i, colAComp)
                            Else
                                compareValuesA(k) = wsFileA.Cells(i, colAComp).Value
                            End If
                        Else
                            If useArrays Then
                                compareValuesA(k) = dataA(i, colA)
                            Else
                                compareValuesA(k) = wsFileA.Cells(i, colA).Value
                            End If
                        End If
                        
                        If colBComp > 0 Then
                            If useArrays Then
                                compareValuesB(k) = dataB(matchRowB, colBComp)
                            Else
                                compareValuesB(k) = wsFileB.Cells(matchRowB, colBComp).Value
                            End If
                        Else
                            If useArrays Then
                                compareValuesB(k) = dataB(matchRowB, colB)
                            Else
                                compareValuesB(k) = wsFileB.Cells(matchRowB, colB).Value
                            End If
                        End If
                    End If
                Next k
                
                ' Now do the comparison in a separate loop (reduces cell access overhead)
                For k = 0 To UBound(mappings, 1)
                    colA = 0
                    colB = 0
                    
                    ' Find column indexes using maps
                    For j = 1 To colMapACount
                        If colMapAKeys(j) = mappings(k, 0) Then
                            colA = colMapAValues(j)
                            Exit For
                        End If
                    Next j
                    
                    For j = 1 To colMapBCount
                        If colMapBKeys(j) = mappings(k, 1) Then
                            colB = colMapBValues(j)
                            Exit For
                        End If
                    Next j
                    
                    If colA > 0 And colB > 0 Then
                        ' Use case-sensitive comparison
                        If (useCaseSensitive And StrComp(compareValuesA(k), compareValuesB(k), vbBinaryCompare) <> 0) Or _
                           (Not useCaseSensitive And StrComp(compareValuesA(k), compareValuesB(k), vbTextCompare) <> 0) Then
                            
                            If hasMismatch Then
                                mismatchedFields = mismatchedFields & ", "
                            End If
                            mismatchedFields = mismatchedFields & mappings(k, 0)
                            hasMismatch = True
                        End If
                    End If
                Next k
            End If
            
            ' Enhanced result message with field mismatches
            If hasMismatch Then
                wsResult.Cells(rowResult, 1).Value = matchType & " - Mismatched Fields: " & mismatchedFields
            Else
                wsResult.Cells(rowResult, 1).Value = matchType & " - All Fields Match"
            End If
            
            ' Write File A data to Result sheet - both original and mapped columns
            colOffset = 2 ' Start after Recon Result column
            
            ' For writing File A data (both original and mapped columns):
            For j = 1 To lastColA
                ' Only process non-mapped columns (we'll add mapped versions right after each original)
                If Right(wsFileA.Cells(3, j).Value, 4) <> "_map" Then
                    ' Copy the original column value
                    If useArrays Then
                        wsResult.Cells(rowResult, colOffset).Value = dataA(i, j)
                    Else
                        wsResult.Cells(rowResult, colOffset).Value = wsFileA.Cells(i, j).Value
                    End If
                    colOffset = colOffset + 1
                    
                    ' Check if there's a mapped version and add it
                    mappedColNameA = wsFileA.Cells(3, j).Value & "_map"
                    mappedColIndex = 0
                    
                    For k = 1 To colMapACount
                        If colMapAKeys(k) = mappedColNameA Then
                            mappedColIndex = colMapAValues(k)
                            Exit For
                        End If
                    Next k
                    
                    If mappedColIndex > 0 Then
                        If useArrays Then
                            wsResult.Cells(rowResult, colOffset).Value = dataA(i, mappedColIndex)
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = wsFileA.Cells(i, mappedColIndex).Value
                        End If
                        colOffset = colOffset + 1
                    End If
                End If
            Next j
            
            ' Write supplementary data for File A if needed
            If hasSupplA And suppColsAInitialized Then
                supplMatchRowA = 0
                
                ' Find matching row in supplementary data
                On Error Resume Next
                For j = 4 To lastRowSupplA
                    Dim supplKeyValueA As String
                    If useArrays Then
                        supplKeyValueA = supplDataA(j, colSupplKeyA)
                    Else
                        supplKeyValueA = Trim(wsSupplA.Cells(j, colSupplKeyA).Value)
                    End If
                    
                    If (useCaseSensitive And StrComp(supplKeyValueA, primaryKeyValueA, vbBinaryCompare) = 0) Or _
                       (Not useCaseSensitive And StrComp(supplKeyValueA, primaryKeyValueA, vbTextCompare) = 0) Then
                        supplMatchRowA = j
                        Exit For
                    End If
                Next j
                On Error GoTo ErrorHandler
                
                ' Write supplementary data
                For j = 0 To UBound(requiredSupplColsA)
                    If requiredSupplColsA(j) <> "" Then
                        If supplMatchRowA > 0 Then
                            On Error Resume Next
                            If useArrays Then
                                wsResult.Cells(rowResult, colOffset).Value = supplDataA(supplMatchRowA, requiredSupplColIndexA(j))
                            Else
                                wsResult.Cells(rowResult, colOffset).Value = wsSupplA.Cells(supplMatchRowA, requiredSupplColIndexA(j)).Value
                            End If
                            If Err.Number <> 0 Then
                                wsResult.Cells(rowResult, colOffset).Value = "Error retrieving data"
                            End If
                            On Error GoTo ErrorHandler
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = "N/A - No supplementary record is found"
                        End If
                        colOffset = colOffset + 1
                    End If
                Next j
            End If
            
            ' For writing File B data (both original and mapped columns):
            For j = 1 To lastColB
                ' Only process non-mapped columns
                If Right(wsFileB.Cells(3, j).Value, 4) <> "_map" Then
                    ' Copy the original column value
                    If useArrays Then
                        wsResult.Cells(rowResult, colOffset).Value = dataB(matchRowB, j)
                    Else
                        wsResult.Cells(rowResult, colOffset).Value = wsFileB.Cells(matchRowB, j).Value
                    End If
                    colOffset = colOffset + 1
                    
                    ' Check if there's a mapped version and add it
                    mappedColNameB = wsFileB.Cells(3, j).Value & "_map"
                    mappedColIndex = 0
                    
                    For k = 1 To colMapBCount
                        If colMapBKeys(k) = mappedColNameB Then
                            mappedColIndex = colMapBValues(k)
                            Exit For
                        End If
                    Next k
                    
                    If mappedColIndex > 0 Then
                        If useArrays Then
                            wsResult.Cells(rowResult, colOffset).Value = dataB(matchRowB, mappedColIndex)
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = wsFileB.Cells(matchRowB, mappedColIndex).Value
                        End If
                        colOffset = colOffset + 1
                    End If
                End If
            Next j
            
            ' Write supplementary data for File B if needed
            If hasSupplB And suppColsBInitialized Then
                supplMatchRowB = 0
                
                ' Get the B primary key value
                Dim matchedPrimaryKeyB As String
                If useArrays Then
                    matchedPrimaryKeyB = dataB(matchRowB, colPrimaryKeyB)
                Else
                    matchedPrimaryKeyB = Trim(wsFileB.Cells(matchRowB, colPrimaryKeyB).Value)
                End If
                
                ' Find matching row in supplementary data
                On Error Resume Next
                For j = 4 To lastRowSupplB
                    Dim supplKeyValueB As String
                    If useArrays Then
                        supplKeyValueB = supplDataB(j, colSupplKeyB)
                    Else
                        supplKeyValueB = Trim(wsSupplB.Cells(j, colSupplKeyB).Value)
                    End If
                    
                    If (useCaseSensitive And StrComp(supplKeyValueB, matchedPrimaryKeyB, vbBinaryCompare) = 0) Or _
                       (Not useCaseSensitive And StrComp(supplKeyValueB, matchedPrimaryKeyB, vbTextCompare) = 0) Then
                        supplMatchRowB = j
                        Exit For
                    End If
                Next j
                On Error GoTo ErrorHandler
                
                ' Write supplementary data
                For j = 0 To UBound(requiredSupplColsB)
                    If requiredSupplColsB(j) <> "" Then
                        If supplMatchRowB > 0 Then
                            On Error Resume Next
                            If useArrays Then
                                wsResult.Cells(rowResult, colOffset).Value = supplDataB(supplMatchRowB, requiredSupplColIndexB(j))
                            Else
                                wsResult.Cells(rowResult, colOffset).Value = wsSupplB.Cells(supplMatchRowB, requiredSupplColIndexB(j)).Value
                            End If
                            If Err.Number <> 0 Then
                                wsResult.Cells(rowResult, colOffset).Value = "Error retrieving data"
                            End If
                            On Error GoTo ErrorHandler
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = "N/A - No supplementary record is found"
                        End If
                        colOffset = colOffset + 1
                    End If
                Next j
            End If
            
            ' Write reconciliation results for each column pair
            If mappingCount > 0 Then
                For k = 0 To UBound(mappings, 1)
                    colA = 0
                    colB = 0
                    
                    ' Find column indexes
                    For j = 1 To colMapACount
                        If colMapAKeys(j) = mappings(k, 0) Then
                            colA = colMapAValues(j)
                            Exit For
                        End If
                    Next j
                    
                    For j = 1 To colMapBCount
                        If colMapBKeys(j) = mappings(k, 1) Then
                            colB = colMapBValues(j)
                            Exit For
                        End If
                    Next j
                    
                    If colA > 0 And colB > 0 Then
                        ' Try to find mapped columns for comparison
                        mappedColNameA = mappings(k, 0) & "_map"
                        mappedColNameB = mappings(k, 1) & "_map"
                        
                        colAComp = 0
                        colBComp = 0
                        
                        For j = 1 To colMapACount
                            If colMapAKeys(j) = mappedColNameA Then
                                colAComp = colMapAValues(j)
                                Exit For
                            End If
                        Next j
                        
                        For j = 1 To colMapBCount
                            If colMapBKeys(j) = mappedColNameB Then
                                colBComp = colMapBValues(j)
                                Exit For
                            End If
                        Next j
                        
                        ' Use mapped columns if available, otherwise use original
                        If colAComp > 0 Then
                            If useArrays Then
                                valueA = dataA(i, colAComp)
                            Else
                                valueA = wsFileA.Cells(i, colAComp).Value
                            End If
                        Else
                            If useArrays Then
                                valueA = dataA(i, colA)
                            Else
                                valueA = wsFileA.Cells(i, colA).Value
                            End If
                        End If
                        
                        If colBComp > 0 Then
                            If useArrays Then
                                valueB = dataB(matchRowB, colBComp)
                            Else
                                valueB = wsFileB.Cells(matchRowB, colBComp).Value
                            End If
                        Else
                            If useArrays Then
                                valueB = dataB(matchRowB, colB)
                            Else
                                valueB = wsFileB.Cells(matchRowB, colB).Value
                            End If
                        End If
                        
                        ' Case-sensitive comparison
                        If (useCaseSensitive And StrComp(valueA, valueB, vbBinaryCompare) = 0) Or _
                           (Not useCaseSensitive And StrComp(valueA, valueB, vbTextCompare) = 0) Then
                            wsResult.Cells(rowResult, colOffset).Value = "MATCH"
                            wsResult.Cells(rowResult, colOffset).Interior.Color = RGB(198, 239, 206) ' Light green
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = "UNMATCH"
                            wsResult.Cells(rowResult, colOffset).Interior.Color = RGB(255, 199, 206) ' Light red
                        End If
                        
                        colOffset = colOffset + 1
                    End If
                Next k
            End If
        Else
            ' This is a singleton in A (no match in B)
            wsResult.Cells(rowResult, 1).Value = "Singleton in " & gstrInputASource
            
            ' Write File A data to Result sheet - both original and mapped columns
            colOffset = 2 ' Start after Recon Result column
            
            ' For writing File A data (both original and mapped columns):
            For j = 1 To lastColA
                ' Only process non-mapped columns (we'll add mapped versions right after each original)
                If Right(wsFileA.Cells(3, j).Value, 4) <> "_map" Then
                    ' Copy the original column value
                    If useArrays Then
                        wsResult.Cells(rowResult, colOffset).Value = dataA(i, j)
                    Else
                        wsResult.Cells(rowResult, colOffset).Value = wsFileA.Cells(i, j).Value
                    End If
                    colOffset = colOffset + 1
                    
                    ' Check if there's a mapped version and add it
                    mappedColNameA = wsFileA.Cells(3, j).Value & "_map"
                    mappedColIndex = 0
                    
                    For k = 1 To colMapACount
                        If colMapAKeys(k) = mappedColNameA Then
                            mappedColIndex = colMapAValues(k)
                            Exit For
                        End If
                    Next k
                    
                    If mappedColIndex > 0 Then
                        If useArrays Then
                            wsResult.Cells(rowResult, colOffset).Value = dataA(i, mappedColIndex)
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = wsFileA.Cells(i, mappedColIndex).Value
                        End If
                        colOffset = colOffset + 1
                    End If
                End If
            Next j
            
            ' Write supplementary data for File A if needed (for singletons)
            If hasSupplA And suppColsAInitialized Then
                supplMatchRowA = 0
                
                ' Find matching row in supplementary data
                On Error Resume Next
                For j = 4 To lastRowSupplA
                    Dim singletonSupplKeyValueA As String
                    If useArrays Then
                        singletonSupplKeyValueA = supplDataA(j, colSupplKeyA)
                    Else
                        singletonSupplKeyValueA = Trim(wsSupplA.Cells(j, colSupplKeyA).Value)
                    End If
                    
                    If (useCaseSensitive And StrComp(singletonSupplKeyValueA, primaryKeyValueA, vbBinaryCompare) = 0) Or _
                       (Not useCaseSensitive And StrComp(singletonSupplKeyValueA, primaryKeyValueA, vbTextCompare) = 0) Then
                        supplMatchRowA = j
                        Exit For
                    End If
                Next j
                On Error GoTo ErrorHandler
                
                ' Write supplementary data
                For j = 0 To UBound(requiredSupplColsA)
                    If requiredSupplColsA(j) <> "" Then
                        If supplMatchRowA > 0 Then
                            On Error Resume Next
                            If useArrays Then
                                wsResult.Cells(rowResult, colOffset).Value = supplDataA(supplMatchRowA, requiredSupplColIndexA(j))
                            Else
                                wsResult.Cells(rowResult, colOffset).Value = wsSupplA.Cells(supplMatchRowA, requiredSupplColIndexA(j)).Value
                            End If
                            If Err.Number <> 0 Then
                                wsResult.Cells(rowResult, colOffset).Value = "Error retrieving data"
                            End If
                            On Error GoTo ErrorHandler
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = "N/A - No supplementary record is found"
                        End If
                        colOffset = colOffset + 1
                    End If
                Next j
            End If
            
            ' For singleton in A, leave B columns empty
            For j = 1 To lastColB
                ' Count both original and mapped columns to skip
                If Right(wsFileB.Cells(3, j).Value, 4) <> "_map" Then
                    colOffset = colOffset + 1 ' Skip original column
                    
                    ' Check if there's a mapped version and skip it too
                    mappedColNameB = wsFileB.Cells(3, j).Value & "_map"
                    mappedColIndex = 0
                    
                    For k = 1 To colMapBCount
                        If colMapBKeys(k) = mappedColNameB Then
                            mappedColIndex = colMapBValues(k)
                            Exit For
                        End If
                    Next k
                    
                    If mappedColIndex > 0 Then
                        colOffset = colOffset + 1 ' Skip mapped column
                    End If
                End If
            Next j
            
            ' Skip supplementary B columns if needed
            If hasSupplB And suppColsBInitialized Then
                Dim suppBColCount As Long
                suppBColCount = 0
                
                ' Count non-empty supplementary columns
                For j = 0 To UBound(requiredSupplColsB)
                    If requiredSupplColsB(j) <> "" Then
                        suppBColCount = suppBColCount + 1
                    End If
                Next j
                
                colOffset = colOffset + suppBColCount
            End If
            
            ' Mark recon columns as Singleton
            For j = 1 To reconColCount
                wsResult.Cells(rowResult, colOffset).Value = "Singleton"
                wsResult.Cells(rowResult, colOffset).Interior.Color = RGB(255, 235, 156) ' Light orange
                colOffset = colOffset + 1
            Next j
        End If
        
        rowResult = rowResult + 1
    Next i
    
    ' Find singletons in File B (records in B with no match in A)
    Application.StatusBar = "Processing File B singletons..."
    
    ' Use a collection to track processed rows so we don't create duplicates
    Dim processedRows As New Collection
    
    ' Now process each record in File B to find singletons
    For i = 4 To lastRowB
        ' Update status bar periodically
        If i Mod 100 = 0 Then
            Application.StatusBar = "Processing File B singletons: " & i & " of " & lastRowB & _
                                   " (" & Format((i - 4) / (lastRowB - 4), "0%") & ")"
        End If
        
        ' Skip if we've already processed this row
        On Error Resume Next
        Dim dummy As Variant
        dummy = processedRows(CStr(i))
        Dim alreadyProcessed As Boolean
        alreadyProcessed = (Err.Number = 0)
        On Error GoTo 0
        
        If Not alreadyProcessed Then
            ' Get key values efficiently
            Dim primaryKeyB As String, secondaryKeyB As String
            
            If useArrays Then
                primaryKeyB = dataB(i, colPrimaryKeyB)
                If colSecondaryKeyB > 0 Then
                    secondaryKeyB = dataB(i, colSecondaryKeyB)
                Else
                    secondaryKeyB = ""
                End If
            Else
                primaryKeyB = Trim(wsFileB.Cells(i, colPrimaryKeyB).Value)
                If colSecondaryKeyB > 0 Then
                    secondaryKeyB = Trim(wsFileB.Cells(i, colSecondaryKeyB).Value)
                Else
                    secondaryKeyB = ""
                End If
            End If
            
            ' Create lookup keys
            Dim lookupCompositeKey As String, lookupPrimaryKey As String
            lookupCompositeKey = GenerateConsistentKey(primaryKeyB, secondaryKeyB, True)
            lookupPrimaryKey = GenerateConsistentKey(primaryKeyB, "", False)
            
            ' Track that we've processed this row
            On Error Resume Next
            processedRows.Add 1, CStr(i)
            On Error GoTo 0
            
            ' Check if this record exists in File A
            matchFound = False
            
            ' Try composite key first if both files have secondary keys
            If colSecondaryKeyA > 0 And colSecondaryKeyB > 0 Then
                Dim compositeIndex As Long
                compositeIndex = KeyExistsInLookup(fileACompositeKeys, fileACompositeCount, lookupCompositeKey, useCaseSensitive)
                
                If compositeIndex > 0 Then
                    matchFound = True
                End If
            End If
            
            ' Try primary key if no composite match
            If Not matchFound Then
                Dim primaryIndex As Long
                primaryIndex = KeyExistsInLookup(fileAPrimaryKeys, fileAPrimaryCount, lookupPrimaryKey, useCaseSensitive)
                
                If primaryIndex > 0 Then
                    matchFound = True
                End If
            End If
            
            ' If no match found, this is a singleton in B
            If Not matchFound Then
                ' Recon Result column
                wsResult.Cells(rowResult, 1).Value = "Singleton in " & gstrInputBSource
                
                ' Skip File A columns (both original and mapped)
                colOffset = 2 ' Start after Recon Result column
                
                For j = 1 To lastColA
                    ' Only process non-mapped columns
                    If Right(wsFileA.Cells(3, j).Value, 4) <> "_map" Then
                        colOffset = colOffset + 1 ' Skip original column
                        
                        ' Check if there's a mapped version and skip it too
                        mappedColNameA = wsFileA.Cells(3, j).Value & "_map"
                        mappedColIndex = 0
                        
                        For k = 1 To colMapACount
                            If colMapAKeys(k) = mappedColNameA Then
                                mappedColIndex = colMapAValues(k)
                                Exit For
                            End If
                        Next k
                        
                        If mappedColIndex > 0 Then
                            colOffset = colOffset + 1 ' Skip mapped column
                        End If
                    End If
                Next j
                
                ' Skip supplementary A columns if needed
                If hasSupplA And suppColsAInitialized Then
                    Dim suppAColCount As Long
                    suppAColCount = 0
                    
                    ' Count non-empty supplementary columns
                    For j = 0 To UBound(requiredSupplColsA)
                        If requiredSupplColsA(j) <> "" Then
                            suppAColCount = suppAColCount + 1
                        End If
                    Next j
                    
                    colOffset = colOffset + suppAColCount
                End If
                
                ' Write File B data - both original and mapped
                For j = 1 To lastColB
                    ' Only process non-mapped columns
                    If Right(wsFileB.Cells(3, j).Value, 4) <> "_map" Then
                        ' Copy the original column value
                        If useArrays Then
                            wsResult.Cells(rowResult, colOffset).Value = dataB(i, j)
                        Else
                            wsResult.Cells(rowResult, colOffset).Value = wsFileB.Cells(i, j).Value
                        End If
                        colOffset = colOffset + 1
                        
                        ' Check if there's a mapped version and add it
                        mappedColNameB = wsFileB.Cells(3, j).Value & "_map"
                        mappedColIndex = 0
                        
                        For k = 1 To colMapBCount
                            If colMapBKeys(k) = mappedColNameB Then
                                mappedColIndex = colMapBValues(k)
                                Exit For
                            End If
                        Next k
                        
                        If mappedColIndex > 0 Then
                            If useArrays Then
                                wsResult.Cells(rowResult, colOffset).Value = dataB(i, mappedColIndex)
                            Else
                                wsResult.Cells(rowResult, colOffset).Value = wsFileB.Cells(i, mappedColIndex).Value
                            End If
                            colOffset = colOffset + 1
                        End If
                    End If
                Next j
                
                ' Write supplementary data for File B if needed
                If hasSupplB And suppColsBInitialized Then
                    singletonSupplMatchRowB = 0
                    
                    ' Find matching row in supplementary data
                    On Error Resume Next
                    For j = 4 To lastRowSupplB
                        Dim singletonSupplKeyValueB As String
                        If useArrays Then
                            singletonSupplKeyValueB = supplDataB(j, colSupplKeyB)
                        Else
                            singletonSupplKeyValueB = Trim(wsSupplB.Cells(j, colSupplKeyB).Value)
                        End If
                        
                        If (useCaseSensitive And StrComp(singletonSupplKeyValueB, primaryKeyB, vbBinaryCompare) = 0) Or _
                           (Not useCaseSensitive And StrComp(singletonSupplKeyValueB, primaryKeyB, vbTextCompare) = 0) Then
                            singletonSupplMatchRowB = j
                            Exit For
                        End If
                    Next j
                    On Error GoTo ErrorHandler
                    
                    ' Write supplementary data
                    For j = 0 To UBound(requiredSupplColsB)
                        If requiredSupplColsB(j) <> "" Then
                            If singletonSupplMatchRowB > 0 Then
                                On Error Resume Next
                                If useArrays Then
                                    wsResult.Cells(rowResult, colOffset).Value = supplDataB(singletonSupplMatchRowB, requiredSupplColIndexB(j))
                                Else
                                    wsResult.Cells(rowResult, colOffset).Value = wsSupplB.Cells(singletonSupplMatchRowB, requiredSupplColIndexB(j)).Value
                                End If
                                If Err.Number <> 0 Then
                                    wsResult.Cells(rowResult, colOffset).Value = "Error retrieving data"
                                End If
                                On Error GoTo ErrorHandler
                            Else
                                wsResult.Cells(rowResult, colOffset).Value = "N/A - No supplementary record is found"
                            End If
                            colOffset = colOffset + 1
                        End If
                    Next j
                End If
                
                ' Mark recon columns as Singleton
                For j = 1 To reconColCount
                    wsResult.Cells(rowResult, colOffset).Value = "Singleton"
                    wsResult.Cells(rowResult, colOffset).Interior.Color = RGB(255, 235, 156) ' Light orange
                    colOffset = colOffset + 1
                Next j
                
                ' Move to next result row
                rowResult = rowResult + 1
            End If
        End If
    Next i
    
    ' Format the Result sheet
    With wsResult.Range("A3:ZZ3")
        .Font.Bold = True
        .Borders.LineStyle = xlContinuous
    End With
    
    With wsResult.Range("A3:ZZ" & (rowResult - 1))
        .Borders.LineStyle = xlContinuous
    End With
    
    ' Auto-fit columns - limit to avoid performance issues on large datasets
    If rowResult < 1000 Then
        wsResult.Columns("B:ZZ").AutoFit
    Else
        ' Just set reasonable widths for very large datasets
        wsResult.Columns("B:ZZ").ColumnWidth = 15
    End If
    
    Application.StatusBar = "Reconciliation complete!"
    Exit Sub
    
ErrorHandler:
    ' Show detailed error information
    MsgBox "Error " & Err.Number & " (" & Err.Description & ")" & vbCrLf & _
           "Procedure: PerformReconciliation" & vbCrLf & _
           "Line: " & Erl, vbCritical, "Error"
End Sub

' Add these helper functions to your module OUTSIDE of any other Sub or Function

' Helper function to find column index from column maps
Function GetColMapValue(keys() As String, values() As Long, count As Long, key As String) As Long
    Dim idx As Long
    GetColMapValue = 0 ' Default not found
    
    For idx = 1 To count
        If keys(idx) = key Then
            GetColMapValue = values(idx)
            Exit Function
        End If
    Next idx
End Function

' Helper function to find a value in the lookup table
Function FindInLookup(keys() As String, values() As Long, count As Long, key As String, caseSensitive As Boolean) As Long
    Dim idx As Long
    FindInLookup = 0 ' Default not found
    
    For idx = 1 To count
        ' Compare using appropriate case sensitivity
        If caseSensitive Then
            ' Case-sensitive comparison (binary comparison)
            If StrComp(keys(idx), key, vbBinaryCompare) = 0 Then
                FindInLookup = values(idx)
                Exit Function
            End If
        Else
            ' Case-insensitive comparison (text compare)
            If StrComp(keys(idx), key, vbTextCompare) = 0 Then
                FindInLookup = values(idx)
                Exit Function
            End If
        End If
    Next idx
End Function


Function FindColumnIndex(ws As Worksheet, columnName As String) As Long

    ' Find the index of a column with the specified name in row 3
    ' Optimized version with early exit
    Dim lastCol As Long
    Dim i As Long

    FindColumnIndex = 0 ' Default to not found

    ' Quick exit for empty name
    If columnName = "" Then Exit Function

    ' Use Range.Find for faster search
    Dim foundCell As Range

    On Error Resume Next
    Set foundCell = ws.Rows(3).Find(What:=columnName, _
                                   LookIn:=xlValues, _
                                   LookAt:=xlWhole, _
                                   SearchOrder:=xlByColumns, _
                                   MatchCase:=False)

    If Not foundCell Is Nothing Then
        FindColumnIndex = foundCell.Column
        Exit Function
    End If

    ' Fallback to linear search if Find fails
    lastCol = ws.Cells(3, ws.Columns.count).End(xlToLeft).Column

    For i = 1 To lastCol
        If ws.Cells(3, i).Value = columnName Then
            FindColumnIndex = i
            Exit Function
        End If
    Next i
End Function

Function GetRequiredSupplementaryColumns(fileType As String) As String()
    ' Get the list of required supplementary columns from the Input Parameters sheet
    Dim ws As Worksheet
    Dim startRow As Long
    Dim i As Long
    Dim colCount As Long
    Dim tempArray() As String
    
    ' Set worksheet
    Set ws = Worksheets("Input Parameters")
    
    ' Determine the start row based on file type
    If fileType = "A" Then
        startRow = 35 ' Adjust if needed based on your actual structure
    ElseIf fileType = "B" Then
        startRow = 46 ' Adjust if needed based on your actual structure
    Else
        ReDim tempArray(0)
        GetRequiredSupplementaryColumns = tempArray
        Exit Function
    End If
    
    ' Count how many columns are required
    colCount = 0
    i = startRow
    
    Do While ws.Cells(i, 1).Value <> ""
        colCount = colCount + 1
        i = i + 1
    Loop
    
    ' If no columns required, return empty array
    If colCount = 0 Then
        ReDim tempArray(0)
        GetRequiredSupplementaryColumns = tempArray
        Exit Function
    End If
    
    ' Get the column names
    ReDim tempArray(colCount - 1)
    
    For i = 0 To colCount - 1
        tempArray(i) = ws.Cells(startRow + i, 1).Value
    Next i
    
    GetRequiredSupplementaryColumns = tempArray
End Function

' =================================== DASHBOARD FUNCTIONS ===================================

Sub ClearDashboardSheet()
    ' Clear both content and formatting from the Dashboard sheet
    On Error GoTo ErrorHandler
    
    Dim wsDashboard As Worksheet
    
    ' Set worksheet
    Set wsDashboard = Worksheets("Dashboard")
    
    ' Preserve title and subtitle
    Dim title As String, subtitle As String
    title = wsDashboard.Range("A1").Value
    subtitle = wsDashboard.Range("A2").Value
    
    ' Clear everything from row 3 down (both content and formatting)
    wsDashboard.Range("A3:ZZ" & wsDashboard.Rows.count).ClearContents
    wsDashboard.Range("A3:ZZ" & wsDashboard.Rows.count).ClearFormats
    
    ' Delete any existing charts
    On Error Resume Next
    If wsDashboard.ChartObjects.count > 0 Then
        wsDashboard.ChartObjects.Delete
    End If
    On Error GoTo ErrorHandler
    
    ' Restore title and subtitle
    wsDashboard.Range("A1").Value = title
    wsDashboard.Range("A1").Font.Bold = True
    wsDashboard.Range("A1").Font.Size = 16
    wsDashboard.Range("A2").Value = subtitle
    wsDashboard.Range("A2").Font.Italic = True
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in ClearDashboardSheet", vbCritical, "Error"
End Sub

Sub GenerateDashboard()
    ' Generate dashboard with reconciliation summary
    On Error GoTo ErrorHandler
    
    Application.ScreenUpdating = False
    
    Dim wsDashboard As Worksheet
    Dim wsResult As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim totalCount As Long
    Dim matchCount As Long
    Dim unmatchCount As Long
    Dim singletonACount As Long
    Dim singletonBCount As Long
    Dim reconResult As String
    
    ' Set worksheets
    Set wsDashboard = Worksheets("Dashboard")
    Set wsResult = Worksheets("Result")
    
    ' Clear dashboard (both content and formatting)
    ClearDashboardSheet
    
    ' Check if reconciliation has been run
    lastRow = wsResult.Cells(wsResult.Rows.count, 1).End(xlUp).Row
    
    If lastRow <= 3 Then
        MsgBox "No reconciliation results found. Please run reconciliation first.", vbExclamation, "No Data"
        GoTo CleanExit
    End If
    
    ' Count reconciliation statuses
    totalCount = lastRow - 3
    matchCount = 0
    unmatchCount = 0
    singletonACount = 0
    singletonBCount = 0
    
    For i = 4 To lastRow
        reconResult = wsResult.Cells(i, 1).Value
        
        If InStr(1, reconResult, "Full Match", vbTextCompare) > 0 Or _
           InStr(1, reconResult, "Primary Key Match", vbTextCompare) > 0 Then
            ' Check if contains "All Fields Match"
            If InStr(1, reconResult, "All Fields Match", vbTextCompare) > 0 Then
                matchCount = matchCount + 1
            Else
                unmatchCount = unmatchCount + 1
            End If
        ElseIf InStr(1, reconResult, "Singleton in " & gstrInputASource, vbTextCompare) > 0 Then
            singletonACount = singletonACount + 1
        ElseIf InStr(1, reconResult, "Singleton in " & gstrInputBSource, vbTextCompare) > 0 Then
            singletonBCount = singletonBCount + 1
        End If
    Next i
    
    ' Populate dashboard summary
    wsDashboard.Range("A3").Value = "RECONCILIATION SUMMARY"
    wsDashboard.Range("A3").Font.Bold = True
    wsDashboard.Range("A3").Font.Size = 14
    
    wsDashboard.Range("A5").Value = "Total Records Processed:"
    wsDashboard.Range("B5").Value = totalCount
    
    wsDashboard.Range("A6").Value = "Fully Matched Records:"
    wsDashboard.Range("B6").Value = matchCount
    wsDashboard.Range("C6").Value = Format(matchCount / totalCount, "0.0%")
    
    wsDashboard.Range("A7").Value = "Records with Differences:"
    wsDashboard.Range("B7").Value = unmatchCount
    wsDashboard.Range("C7").Value = Format(unmatchCount / totalCount, "0.0%")
    
    wsDashboard.Range("A8").Value = "Singletons in " & gstrInputASource & ":"
    wsDashboard.Range("B8").Value = singletonACount
    wsDashboard.Range("C8").Value = Format(singletonACount / totalCount, "0.0%")
    
    wsDashboard.Range("A9").Value = "Singletons in " & gstrInputBSource & ":"
    wsDashboard.Range("B9").Value = singletonBCount
    wsDashboard.Range("C9").Value = Format(singletonBCount / totalCount, "0.0%")
    
    ' Format dashboard
    wsDashboard.Range("A5:C9").Borders.LineStyle = xlContinuous
    
    ' Add a simple chart
    CreateDashboardChart wsDashboard, matchCount, unmatchCount, singletonACount, singletonBCount
    
    ' Auto-fit columns
    wsDashboard.Columns("A:C").AutoFit
    
CleanExit:
    Application.ScreenUpdating = True
    
    If Err.Number = 0 Then
        MsgBox "Dashboard generated successfully!", vbInformation, "Dashboard Complete"
    End If
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Error " & Err.Number & ": " & Err.Description & " in GenerateDashboard", vbCritical, "Error"
    Resume CleanExit
End Sub

Function IsRowFullMatch(wsResult As Worksheet, rowNum As Long) As Boolean
    ' Check if all reconciliation columns in a row show "MATCH"
    Dim lastCol As Long
    Dim i As Long
    
    lastCol = wsResult.Cells(3, wsResult.Columns.count).End(xlToLeft).Column
    
    ' Start from the first reconciliation column
    For i = lastCol - 10 To lastCol ' Assumption: last 10 columns are recon results
        If wsResult.Cells(3, i).Value Like "*Recon*" Then
            If wsResult.Cells(rowNum, i).Value <> "MATCH" And _
               wsResult.Cells(rowNum, i).Value <> "Singleton" Then
                IsRowFullMatch = False
                Exit Function
            End If
        End If
    Next i
    
    IsRowFullMatch = True
End Function

Sub CreateDashboardChart(ws As Worksheet, matchCount As Long, unmatchCount As Long, _
                         singletonACount As Long, singletonBCount As Long)
    ' Create a simple chart in the dashboard
    Dim chartObj As ChartObject
    Dim chartData As Range
    
    ' Create data for chart
    ws.Range("E5").Value = "Category"
    ws.Range("F5").Value = "Count"
    
    ws.Range("E6").Value = "Matched"
    ws.Range("F6").Value = matchCount
    
    ws.Range("E7").Value = "Unmatched"
    ws.Range("F7").Value = unmatchCount
    
    ws.Range("E8").Value = "Singleton in " & gstrInputASource
    ws.Range("F8").Value = singletonACount
    
    ws.Range("E9").Value = "Singleton in " & gstrInputBSource
    ws.Range("F9").Value = singletonBCount
    
    ' Create chart
    Set chartData = ws.Range("E5:F9")
    
    ' Delete any existing charts
    If ws.ChartObjects.count > 0 Then
        ws.ChartObjects.Delete
    End If
    
    ' Create new chart
    Set chartObj = ws.ChartObjects.Add(320, 50, 400, 250)
    
    With chartObj.Chart
        .SetSourceData Source:=chartData
        .ChartType = xlPie
        .HasTitle = True
        .ChartTitle.text = "Reconciliation Results"
        .HasLegend = True
        .Legend.Position = xlLegendPositionRight
    End With
    
    ' Apply colors
    chartObj.Chart.SeriesCollection(1).Points(1).Interior.Color = RGB(146, 208, 80) ' Green for matches
    chartObj.Chart.SeriesCollection(1).Points(2).Interior.Color = RGB(255, 0, 0)    ' Red for unmatches
    chartObj.Chart.SeriesCollection(1).Points(3).Interior.Color = RGB(255, 192, 0)  ' Orange for singleton A
    chartObj.Chart.SeriesCollection(1).Points(4).Interior.Color = RGB(0, 176, 240)  ' Blue for singleton B
End Sub

' =================================== RUN ALL STEPS ===================================

Sub RunAllSteps()
    ' Run all reconciliation steps in sequence
    Application.ScreenUpdating = False
    
    ' Load Input Files
    LoadInputFiles
    
    ' Load Supplementary Files
    LoadSupplementaryFiles
    
    ' Apply Mapping
    ApplyMapping
    
    ' Run Reconciliation
    RunReconciliation
    
    ' Generate Dashboard
    GenerateDashboard
    
    Application.ScreenUpdating = True
    MsgBox "All reconciliation steps completed successfully!", vbInformation, "Process Complete"
End Sub

' =================================== PLATFORM SPECIFIC NOTES ===================================

' ===== WINDOWS VS MACOS COMPATIBILITY NOTES =====
'
' 1. File Paths:
'    - macOS uses forward slashes (/) in file paths
'    - Windows uses backslashes (\) in file paths
'    - When moving to Windows, you may need to update file paths or use Replace() to convert slashes
'
' 2. File Dialogs:
'    - This code uses simple file path input via cells rather than file dialogs for better cross-platform compatibility
'    - If you add file dialogs later, note that Application.FileDialog works differently across platforms
'
' 3. ActiveX Controls:
'    - This code uses Form controls (Buttons) instead of ActiveX controls for better macOS compatibility
'    - On Windows, you might prefer ActiveX controls for more formatting options
'
' 4. Line Endings:
'    - macOS and Windows use different line ending characters, which can affect text file parsing
'    - The code handles this automatically using Line Input
'
' 5. Performance:
'    - Excel on Windows typically performs better with large datasets
'    - If you have performance issues on macOS, consider loading smaller chunks of data
'
' 6. Color Models:
'    - This code uses RGB() for colors which works on both platforms
'    - Some advanced color features might behave differently across platforms
'
' 7. Chart Objects:
'    - Chart object behavior can vary slightly between platforms
'    - The code uses basic chart properties that work on both platforms



